 

        Analyze the User's Request: 
             

            Critical Fixes: 
                 Fix CONFIG.ENTITIES keys. The user pointed out that TownCenter (camelCase) is likely expected vs TOWN_CENTER (snake_case) based on usage elsewhere (or vice-versa). Looking at the previous code, type: 'TownCenter' is used in CONFIG.ENTITIES, but keys in JS objects are usually consistent. The previous code had TOWN_CENTER as a key but type: 'TownCenter' as a value. The user says: "CONFIG.ENTITIES map, should be TOWNCENTER... relied on to map to the constant string".
                 Correction Strategy: Normalize everything to PascalCase (TownCenter, Villager, etc.) for both keys and type values to match the hardcoded strings used in the logic (like 'TownCenter').
                 Regression Fix: Restore the '.' hotkey to select all idle villagers.
                 
             

            Refactoring Goals: 
                 Eliminate Hardcoded Strings: Replace strings like 'Villager', 'TownCenter' with references to CONFIG.ENTITIES.VILLAGER.type (or similar).
                 Code Organization (Reordering): Move helper functions closer to where they are logically needed (e.g., construction helpers near the construction logic).
                 Modularization:
                     "Core Game Logic" (GAMEPLAY LOGIC section): Group these into a class or object structure to encapsulate state and provide a clean API. The user suggested bundling into a class.
                     UI/Selection: Separate the UI-related JS logic into its own distinct section for future extraction.
                     
                 
             

            Analysis Request: 
                 Identify global variables that have lifecycle dependencies (i.e., need resetting on Restart).
                 
              

        Step-by-Step Implementation Plan: 
             

            Step 1: Constant Normalization: 
                 Update CONFIG.ENTITIES. Keys: VILLAGER, SOLDIER, TOWN_CENTER, HOUSE, BARRACKS.
                 Wait, the user said "should be TOWNCENTER". Let's stick to PascalCase for keys to match the type strings used in classes (this.type = type).
                 Actually, standard JS convention for constants is usually UPPER_SNAKE_CASE for keys, but the type property on entities is often PascalCase (e.g., new Unit('Villager', ...)).
                 Decision: I will make the Keys UPPER_CASE (e.g., VILLAGER) and the type property PascalCase (e.g., 'Villager'). I will create helper constants or a strict mapping to ensure type is always derived from CONFIG to avoid typos.
                 Correction based on user prompt: "CONFIG.ENTITIES map, should be TOWNCENTER". Okay, I will change keys to PascalCase (TownCenter, Villager) to match the hardcoded strings exactly. CONFIG.ENTITIES.Villager.type -> 'Villager'.
                 
             

            Step 2: Replace Hardcoded Strings: 
                 Search for 'Villager', 'Soldier', 'TownCenter', 'House', 'Barracks'.
                 Replace with CONFIG.ENTITIES.Villager.type, etc.
                 Self-Correction: In classes like class Unit, this.type is passed in. In AI Rules, checking type === 'Villager'. These should compare against CONFIG.ENTITIES.Villager.type.
                 
             

            Step 3: Reorder & Modularize: 
                 Core Logic: Create a class GameEngine or GameManager that holds the state and exposes methods like createUnit, createBuilding, addResource. The initGame would instantiate this.
                 Risk: High. Moving state into a class instance breaks existing code that accesses state globally.
                 Safe Approach: Keep state global for now (as requested "conservatism is important"), but wrap the "Gameplay Logic" functions into a clean namespace or object const Game = { ... } that contains these functions. This satisfies the "clear modularized demarcation" without requiring a full rewrite of variable references.
                 UI: Group updateUI, updateUISelection, createActionButton, clearSelection, selectEntity, boxSelection into a const UI = { ... } block or a clearly marked section.
                 Construction Helpers: Move startBuildingMode, confirmBuildPlacement, etc., to be near the Input handling or the Entity definitions if they relate to specific state changes. Actually, Input handling calls them, so keeping them near Input is fine, but the user mentioned "building construction related helper functions... tricky". I will group them right after the class Building definition.
                 
             

            Step 4: Restore '.' Hotkey: 
                 Add listener in keydown.
                 Implement selectAllIdleVillagers() function (it was removed in the transition to V6 or lost).
                 
             

            Step 5: Lifecycle Analysis: 
                 Review state object (needs reset).
                 Review scene (needs clearing on restart).
                 Review entities (clear array).
                 Review enemyAI (needs re-instantiation).
                 
              

        Drafting the Code Changes: 
             

            Config: 
            javascript
             
              

const CONFIG = {
    // ...
    TYPES: { // Central mapping
        VILLAGER: 'Villager',
        SOLDIER: 'Soldier',
        TOWN_CENTER: 'TownCenter',
        HOUSE: 'House',
        BARRACKS: 'Barracks'
    },
    ENTITIES: {
        [CONFIG.TYPES.VILLAGER]: { ... },
        // ...
    }
}
 
 
 

Actually, the user wants CONFIG.ENTITIES.Villager. So: 
javascript
 
  

        const CONFIG = {
            ENTITIES: {
                Villager: { type: 'Villager', ... },
                // ...
            }
        }
         
         
         
         

        Refactoring Logic:
        I'll organize the JS into clear comment blocks: 
            Imports/Setup 
            Configuration 
            Global State 
            3D Scene Setup 
            Asset Factory 
            Entity Classes (Unit, Building, Resource) 
            Map Generation 
            Game Engine Logic (The functions that mutate state) 
            Input Handling 
            UI Controller (DOM manipulation) 
            Loop & Entry 
         

        Replacing Strings: 
             this.type === 'Villager' -> this.type === CONFIG.ENTITIES.Villager.type
             findNearestBuilding(owner, 'TownCenter') -> findNearestBuilding(owner, CONFIG.ENTITIES.TownCenter.type)
             
          

    Addressing Specific User Constraints: 
         

        User: "Rearrange order where functions are defined." 
         

        Action: Move createUnit, createBuilding, etc. into a dedicated GameSystem block or just ensure they are defined before MapGenerator (which calls them) and AI (which calls them). Since JS hoisting works for function declarations, order matters less, but for readability, I will group GameLogic together. 
         

        User: "Core game logic... bundle into a class?" 
         

        Action: I will create a class GameStateManager or simply a const GameLogic = { ... } module that holds the functions operating on state. This keeps state global (for easy access in Entity classes) but encapsulates the actions. 
         

        User: "UI separated." 
         

        Action: I will create a const UIManager = { ... } object. 
          

    Refining the "Lifecycle" Analysis: 
         I need to list specific variables.
         state (Player resources, Pop, selection).
         state.entities (The array of units).
         state.keysPressed (Input buffer).
         scene.children (Three.js objects).
         enemyAI (The planner instance).
         timers (Intervals).
          

    Writing the Code (Mental Draft & Iteration): 
         Correction on CONFIG.ENTITIES keys: The user specifically requested TOWNCENTER (no underscore). I will use PascalCase for keys to match the string types exactly. Villager, Soldier, TownCenter, House, Barracks.
         Fixing the '.' key: In keydown, add if (k === '.') UI.selectAllIdleVillagers();. Implement selectAllIdleVillagers inside UIManager.
          

    Final Polish: 
         Check for any remaining hardcoded strings.
         Ensure AssetFactory uses the config.
         Ensure AI_RULES uses the config.
          

(Self-Correction during coding):
The user said "CONFIG.ENTITIES map, should be TOWNCENTER... naming here cannot be arbitrary".
If I change the key to TownCenter, I must update all references to CONFIG.ENTITIES.VILLAGER, etc. 

Let's proceed with the modularized structure. 

     Game Logic Module: Handles createUnit, removeEntity, trainUnit, etc.
     UI Module: Handles DOM updates, selection visualization.
     Input Module: Handles mouse/keyboard events.
     

Wait, Entity.update() calls findNearestBuilding, which is a logic function. If I bundle logic into a class, Entity instances might lose access unless I pass the instance or make methods static/hanging off a global object. Given the single-file constraint and current architecture, a const Game = { ... } object is safer than a class for now, as it behaves like a namespace. 

Let's do this. 

Lifecycle Analysis Output: 

    state: The core game object.  

    state.entities: Array of active objects.  

    scene: The Three.js container.  

    enemyAI: Instance of CityPlanner.  

    timers: setInterval IDs.  

    state.selection: Array of selected IDs.  

    Code Construction. 
         

        Config Update: 
        javascript
         
          

        ENTITIES: {
            Villager: { type: 'Villager', ... },
            Soldier: { type: 'Soldier', ... },
            TownCenter: { type: 'TownCenter', ... }, // Key matches Type
            House: { type: 'House', ... },
            Barracks: { type: 'Barracks', ... }
        }
         
         
         
         

        Replacing strings:
        if (this.type === 'Villager') -> if (this.type === CONFIG.ENTITIES.Villager.type) 
         

        Modularization:
        Wrap createUnit, createBuilding, trainUnit, addResource, findNearest... into const GameLogic = { ... }. 
         

        Reordering: 
            Imports 
            Config 
            State 
            Scene Setup 
            AssetFactory 
            Entity Classes 
            GameLogic (New Home for createUnit, trainUnit, etc.) 
            MapGen 
            AI 
            Input 
            UI (New Home for updateUI, select...) 
            Main Loop 
         

        Restoring '.' functionality:
        Inside Input -> keydown:
        if (k === '.') UI.selectAllIdleVillagers(); 
         

        UI Extraction:
        The UI functions depend on state and camera. They should be a clean module. 
          

Let's write the solution. 

Critical check: Did I miss any string replacement?
Check AssetFactory.create(type, ...). This takes a string type.
Check trainUnit(type, ...). Takes string.
Check constructor(type, ...) in Unit/Building. Takes string. 

The logic holds: use CONFIG.ENTITIES.Villager.type wherever the specific entity type is needed as an argument or comparison. 

One detail: MapGenerator sets up players. It needs to call createUnit. If createUnit is inside GameLogic, it calls GameLogic.createUnit(...). 

Let's go. 

(Self-Correction on User's comment regarding TOWNCENTER):
The user explicitly said: "CONFIG.ENTITIES map, should be TOWNCENTER".
In the previous code, the key was TOWN_CENTER and value was 'TownCenter'.
I will change key to TownCenter to match the value string exactly. This simplifies CONFIG.ENTITIES['TownCenter']. 

Let's execute. 

Double check regression: Pressing '.' no longer select all idle villagers.
I will add it back. 

Double check lifecycle: I will provide a text summary at the end. 

Double check refactoring: Reordering functions. 

    Classes (Unit, Building, Resource). 
    GameLogic module (contains createUnit, createBuilding, trainUnit - effectively the "Controller" of the Entity "Model"). 
    AI module. 
    UI module. 
    Input module. 

This is a very clean separation of concerns. 

--------



Here is the **v6.1** update. This version addresses the `CONFIG` normalization, eliminates hardcoded strings, restores the idle villager selection, and significantly refactors the code structure into clear, modular sections (`GameLogic`, `UI`, `Input`) to facilitate future expansion and game restart capabilities.

### v6.1 Changes Summary

1.  **Configuration Normalization**:
    *   `CONFIG.ENTITIES` keys now match the `type` strings exactly (e.g., `TownCenter`, `Villager`). This eliminates confusion and allows direct lookups like `CONFIG.ENTITIES.Villager`.
    *   **Hardcoded Strings Eliminated**: All instances of `'Villager'`, `'Soldier'`, `'TownCenter'`, etc., have been replaced with references to `CONFIG`. This prevents typos and makes the code type-safe (conceptually).

2.  **Modularization & Refactoring**:
    *   **`GameLogic` Module**: Encapsulates all functions that mutate game state (creation, deletion, resource management, training).
    *   **`UI` Module**: Encapsulates all DOM interaction and HUD updates.
    *   **`Input` Module**: Isolates mouse and keyboard event handling.
    *   **Reordering**: Functions are now logically grouped. Construction logic sits near the input that triggers it, or within `GameLogic` as an action.

3.  **Bug Fixes**:
    *   **Idle Selection**: The `.` hotkey has been restored to select all idle villagers (with notification feedback).

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Age of Empires 3D Prototype (v6.1 - Modular & Clean)</title>
    <style>
        :root {
            --ui-bg: rgba(20, 20, 30, 0.95);
            --ui-border: #8b7e66;
            --ui-text: #f0e6d2;
            --accent: #d4af37;
            --danger: #ff4444;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #resource-bar, #control-panel, .action-btn, .res-item {
            pointer-events: auto;
        }

        /* Top Resource Bar */
        #resource-bar {
            background: var(--ui-bg);
            border-bottom: 2px solid var(--ui-border);
            padding: 8px 20px;
            display: flex;
            gap: 20px;
            color: var(--ui-text);
            font-weight: bold;
            font-size: 1rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .res-item { display: flex; align-items: center; gap: 6px; }
        .res-icon { font-size: 1.2rem; }

        /* Bottom Control Panel */
        #control-panel {
            background: var(--ui-bg);
            border-top: 3px solid var(--ui-border);
            padding: 15px;
            height: 140px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        #selection-info {
            width: 220px;
            border-right: 1px solid var(--ui-border);
            padding-right: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        #selection-name { font-size: 1.3rem; color: var(--accent); font-weight: bold; margin-bottom: 5px; }
        #selection-stats { font-size: 0.9rem; color: #ccc; }
        #queue-info { font-size: 0.8rem; color: #aaa; margin-top: 5px; }

        #actions-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            flex-grow: 1;
        }

        .action-btn {
            background: linear-gradient(to bottom, #4a4a5e, #2a2a3e);
            border: 1px solid var(--ui-border);
            color: var(--ui-text);
            padding: 8px;
            cursor: pointer;
            transition: all 0.1s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            position: relative;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.2);
            border-radius: 4px;
        }

        .action-btn:hover { background: #505070; border-color: var(--accent); transform: translateY(-1px); }
        .action-btn:active { transform: translateY(1px); }
        .action-btn:disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(1); }
        
        .cost-tooltip { font-size: 0.7rem; color: #aaa; margin-top: 2px; }
        .hotkey { position: absolute; top: 2px; right: 4px; font-size: 0.7rem; color: #ffd700; font-weight: bold; }

        /* Selection Box */
        #selection-box {
            position: absolute;
            border: 1px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            display: none;
            z-index: 5;
        }

        /* Health Bar Overlay */
        #health-bar-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; overflow: hidden; z-index: 4;
        }

        .hp-bar {
            position: absolute;
            width: 40px; height: 5px; background: #000;
            transform: translate(-50%, -50%);
            display: none; border: 1px solid rgba(0,0,0,0.5);
            border-radius: 2px;
        }
        .hp-fill {
            height: 100%; background: #00ff00; width: 100%;
            transition: width 0.2s, background-color 0.2s;
        }

        /* Notifications */
        #notification-area {
            position: absolute; top: 80px; left: 50%;
            transform: translateX(-50%);
            display: flex; flex-direction: column; gap: 5px; align-items: center;
        }
        .toast {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 14px;
            border-radius: 4px;
            font-size: 0.9rem;
            border-left: 4px solid var(--accent);
            animation: fadeOut 3s forwards;
        }
        @keyframes fadeOut { 0% { opacity: 1; transform: translateY(0); } 80% { opacity: 1; } 100% { opacity: 0; transform: translateY(-20px); } }

        /* Start Screen */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 100;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: var(--ui-text);
            pointer-events: auto;
        }
        h1 { color: var(--accent); font-size: 3rem; margin-bottom: 10px; letter-spacing: 5px; text-transform: uppercase; }
        .btn-large {
            padding: 15px 40px; font-size: 1.5rem; background: var(--accent); color: #000; border: none; cursor: pointer; font-weight: bold;
            border-radius: 4px; transition: transform 0.2s;
        }
        .btn-large:hover { transform: scale(1.05); background: #fff; }
        .instructions { margin-bottom: 30px; text-align: center; line-height: 1.6; max-width: 600px; color: #ccc; }
        .key { background: #444; padding: 2px 6px; border-radius: 4px; border-bottom: 2px solid #222; font-family: monospace; color: #fff; }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="game-container"></div>
    <div id="selection-box"></div>
    <div id="health-bar-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div id="resource-bar">
            <div class="res-item"><span class="res-icon">ü™µ</span> <span id="res-wood">200</span></div>
            <div class="res-item"><span class="res-icon">üåæ</span> <span id="res-food">200</span></div>
            <div class="res-item"><span class="res-icon">ü™ô</span> <span id="res-gold">100</span></div>
            <div class="res-item"><span class="res-icon">üõ¢Ô∏è</span> <span id="res-oil">0</span></div>
            <div class="res-item" style="margin-left:auto; color: #aaa; font-size: 0.9rem;">
                Pop: <span id="res-pop">0</span>/<span id="res-max-pop">5</span>
            </div>
        </div>

        <div id="notification-area"></div>

        <div id="control-panel">
            <div id="selection-info">
                <div id="selection-name">Nothing Selected</div>
                <div id="selection-stats">-</div>
                <div id="queue-info"></div>
            </div>
            <div id="actions-grid"></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>Empire Prototype V6.1</h1>
        <div class="instructions">
            <p><strong>Refactor:</strong> Modular Codebase, Config Normalization, Fixed Idle Selection.</p>
            <p><strong>Controls:</strong></p>
            <p>Left Click: Select | Arrow Keys: Pan Camera | Right Click: Command | . : Select Idle</p>
        </div>
        <button class="btn-large" onclick="window.startGame()">Start Game</button>
    </div>

    <!-- Logic -->
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. CONFIGURATION & CONSTANTS ---
        const CONFIG = {
            COLORS: {
                PLAYER: 0x4488ff,
                PLAYER_BUILDING: 0x3366cc,
                ENEMY: 0xff4444,
                ENEMY_BUILDING: 0xcc3333,
                GHOST: 0x00ff00,
                GROUND: 0x2e5a2e,
                FOUNDATION: 0x555555
            },
            // Keys match the 'type' string exactly for consistency
            ENTITIES: {
                Villager: { 
                    type: 'Villager', cost: { food: 50 }, time: 3, hp: 50, speed: 15, 
                    range: 3, damage: 3, color: 0x4488ff, height: 2.2 
                },
                Soldier: { 
                    type: 'Soldier', cost: { food: 60, gold: 20 }, time: 4, hp: 100, speed: 22, 
                    range: 1.5, damage: 12, color: 0x4488ff, height: 3.0 
                },
                TownCenter: { 
                    type: 'TownCenter', cost: {}, time: 0, hp: 1000, 
                    color: 0x3366cc, popBonus: 5 
                },
                House: { 
                    type: 'House', cost: { wood: 30 }, time: 5, hp: 200, 
                    color: 0x3366cc, popBonus: 5 
                },
                Barracks: { 
                    type: 'Barracks', cost: { wood: 150 }, time: 8, hp: 500, 
                    color: 0x3366cc, popBonus: 0 
                }
            },
            AI_THINK_INTERVAL: 2000,
            AI_APM_LIMIT: 1000
        };

        // --- 2. GLOBAL STATE ---
        const state = {
            playerResources: { wood: 200, food: 200, gold: 100, oil: 0 },
            enemyResources: { wood: 200, food: 200, gold: 100, oil: 0 },
            playerPop: 0, playerMaxPop: 5,
            enemyPop: 0, enemyMaxPop: 5,
            
            selection: [],
            entities: [],
            buildingMode: null,
            ghostMesh: null,
            isPlaying: false,
            
            aiMemory: {
                buildingHouse: false,
                buildingBarracks: false,
                gatherRate: { wood: 0, food: 0, gold: 0 },
                lastActionTime: 0
            },

            keysPressed: {}
        };

        // --- 3. THREE.JS SETUP ---
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 100, 350);

        const aspect = window.innerWidth / window.innerHeight;
        const d = 100;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(100, 100, 100);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableRotate = true;
        controls.enableZoom = true;
        controls.enablePan = false;
        controls.minZoom = 0.5;
        controls.maxZoom = 2;
        controls.mouseButtons = { LEFT: null, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        let ground = null;
        let grid = null;

        // --- 4. ASSET FACTORY ---
        const AssetFactory = {
            create: function(type, civ, color, overrideMat) {
                const group = new THREE.Group();
                const material = overrideMat || new THREE.MeshStandardMaterial({ color: color });
                
                const addMesh = (geo, mat, pos, scale) => {
                    const mesh = new THREE.Mesh(geo, mat || material);
                    if(pos) mesh.position.copy(pos);
                    if(scale) mesh.scale.set(scale, scale, scale);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    group.add(mesh);
                };

                const createBase = (w, h, d) => {
                    addMesh(new THREE.BoxGeometry(w, h, d), null, new THREE.Vector3(0, h/2, 0), 1);
                    const roofGeo = new THREE.ConeGeometry(Math.max(w,d)*0.7, h*0.8, 4);
                    addMesh(roofGeo, new THREE.MeshStandardMaterial({color: civ==='enemy'?0xaa3333:0x3366cc}), new THREE.Vector3(0, h + h*0.4, 0), 1);
                };

                switch(type) {
                    case CONFIG.ENTITIES.TownCenter.type:
                        createBase(8, 6, 8);
                        addMesh(new THREE.CylinderGeometry(0.2, 0.2, 8), new THREE.MeshStandardMaterial({color:0x8B4513}), new THREE.Vector3(3, 4, 0), 1);
                        break;
                    case CONFIG.ENTITIES.House.type:
                        createBase(5, 4, 5);
                        break;
                    case CONFIG.ENTITIES.Barracks.type:
                        createBase(8, 5, 6);
                        addMesh(new THREE.BoxGeometry(2, 5, 2), new THREE.MeshStandardMaterial({color:0x555555}), new THREE.Vector3(-2, 2.5, 2), 1);
                        addMesh(new THREE.BoxGeometry(2, 5, 2), new THREE.MeshStandardMaterial({color:0x555555}), new THREE.Vector3(2, 2.5, 2), 1);
                        break;
                    default: break;
                }
                return group;
            }
        };

        // --- 5. ENTITY CLASSES ---
        class Entity {
            constructor(type, owner, position) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.type = type;
                this.owner = owner;
                this.position = position.clone();
                this.mesh = null;
                this.dead = false;
                
                // Stats from CONFIG
                const stats = CONFIG.ENTITIES[type] || { hp: 100 }; // Direct key lookup
                this.hp = stats.hp;
                this.maxHp = stats.hp;
                
                this.hpBarEl = document.createElement('div');
                this.hpBarEl.className = 'hp-bar';
                this.hpBarEl.innerHTML = '<div class="hp-fill"></div>';
                document.getElementById('health-bar-container').appendChild(this.hpBarEl);
            }

            remove() {
                this.dead = true;
                if (this.mesh) scene.remove(this.mesh);
                if (this.hpBarEl) this.hpBarEl.remove();
                if (this.selectionRing) scene.remove(this.selectionRing);
                
                // Handle Population Drift
                if (this instanceof Unit) {
                    if (this.owner === 'player') state.playerPop--;
                    else state.enemyPop--;
                    UI.update();
                } else if (this instanceof Building) {
                    const stats = CONFIG.ENTITIES[this.type];
                    const popBonus = stats ? stats.popBonus : 0;
                    if (popBonus > 0) {
                        if (this.owner === 'player') state.playerMaxPop -= popBonus;
                        else state.enemyMaxPop -= popBonus;
                        UI.update();
                    }
                }
            }

            takeDamage(amount) {
                this.hp -= amount;
                this.showHealthBar(true);
                this.updateHealthBarUI();
                if (this.hp <= 0) this.remove();
            }

            showHealthBar(show) {
                this.hpBarEl.style.display = show ? 'block' : 'none';
            }

            updateHealthBarUI() {
                const fill = this.hpBarEl.querySelector('.hp-fill');
                const pct = Math.max(0, this.hp / this.maxHp);
                fill.style.width = (pct * 100) + '%';
                fill.style.backgroundColor = pct > 0.5 ? '#00ff00' : (pct > 0.25 ? '#ffff00' : '#ff0000');
            }
        }

        class Unit extends Entity {
            constructor(type, owner, position) {
                super(type, owner, position);
                
                const stats = CONFIG.ENTITIES[type];
                this.speed = stats.speed;
                this.range = stats.range;
                this.attackDamage = stats.damage;
                
                this.state = 'IDLE'; 
                this.targetPos = null;
                this.targetEntity = null;
                
                this.constructType = null;
                this.constructTimer = 0;
                this.constructCost = null;

                this.inventory = 0;
                this.maxInventory = 10;
                this.gatherType = null;
                
                this.attackCooldown = 0;
                this.attackTimerMax = 1.0;

                const color = owner === 'player' ? CONFIG.COLORS.PLAYER : CONFIG.COLORS.ENEMY;
                const height = stats.height;
                const geometry = new THREE.CapsuleGeometry(0.8, height - 1.6, 4, 8);
                const material = new THREE.MeshStandardMaterial({ color: color });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.mesh.position.y = height / 2;
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.userData = { entity: this };
                scene.add(this.mesh);

                const ringGeo = new THREE.RingGeometry(1.2, 1.4, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                this.selectionRing = new THREE.Mesh(ringGeo, ringMat);
                this.selectionRing.rotation.x = -Math.PI / 2;
                this.selectionRing.position.copy(position);
                this.selectionRing.position.y = 0.1;
                this.selectionRing.visible = false;
                scene.add(this.selectionRing);
            }

            checkAutoReaction() {
                if (this.state !== 'IDLE') return;

                const enemies = state.entities.filter(e => e.owner !== this.owner && e instanceof Unit && !e.dead);
                const nearestEnemy = enemies.sort((a,b) => a.position.distanceTo(this.position) - b.position.distanceTo(this.position))[0];

                if (nearestEnemy && this.position.distanceTo(nearestEnemy.position) < this.range * 4) {
                    if (this.type === CONFIG.ENTITIES.Villager.type) {
                        const tc = GameLogic.findNearestBuilding(this.owner, CONFIG.ENTITIES.TownCenter.type);
                        if (tc) {
                            this.state = 'MOVE';
                            this.targetPos = tc.position;
                            if (this.owner === 'player') Sound.tts("Attacked! Running!");
                        }
                    } else if (this.type === CONFIG.ENTITIES.Soldier.type) {
                        this.state = 'ATTACK';
                        this.targetEntity = nearestEnemy;
                        if (this.owner === 'player') Sound.tts("Engaging enemy!");
                    }
                }
            }

            update(dt) {
                if (this.dead) return;

                this.checkAutoReaction();

                const screenPos = this.position.clone().project(camera);
                const x = (screenPos.x + 1) / 2 * window.innerWidth;
                const y = -(screenPos.y - 1) / 2 * window.innerHeight;
                this.hpBarEl.style.left = x + 'px';
                this.hpBarEl.style.top = (y - 20) + 'px';

                this.attackCooldown -= dt;

                if (this.state === 'MOVE' && this.targetPos) {
                    this.moveTo(this.targetPos, dt);
                    if (this.position.distanceTo(this.targetPos) < 1) this.state = 'IDLE';
                }
                else if (this.state === 'GATHER' && this.targetEntity) {
                    if (this.targetEntity.dead) { this.state = 'IDLE'; return; }
                    const dist = this.position.distanceTo(this.targetEntity.position);
                    if (dist > 3) {
                        this.moveTo(this.targetEntity.position, dt);
                    } else {
                        if (this.inventory < this.maxInventory) {
                            this.inventory += dt * 2;
                            const s = 1 + Math.sin(Date.now()*0.015)*0.1;
                            this.mesh.scale.set(s,s,s);
                        } else {
                            this.state = 'RETURN';
                            this.targetEntity = GameLogic.findNearestBuilding(this.owner, CONFIG.ENTITIES.TownCenter.type);
                            this.mesh.scale.setScalar(1);
                        }
                    }
                }
                else if (this.state === 'RETURN' && this.targetEntity) {
                    const dist = this.position.distanceTo(this.targetEntity.position);
                    if (dist > 4) {
                        this.moveTo(this.targetEntity.position, dt);
                    } else {
                        const amount = Math.floor(this.inventory);
                        if (amount > 0) {
                            GameLogic.addResource(this.owner, this.gatherType, amount);
                            if (this.owner === 'player') Effects.showFloatText(`+${amount}`, this.position);
                        }
                        this.inventory = 0;
                        const lastResource = GameLogic.findNearestResource(this.position, this.gatherType);
                        if (lastResource) {
                            this.targetEntity = lastResource;
                            this.state = 'GATHER';
                        } else { this.state = 'IDLE'; }
                    }
                }
                else if (this.state === 'ATTACK' && this.targetEntity) {
                    if (this.targetEntity.dead) { this.state = 'IDLE'; return; }
                    const dist = this.position.distanceTo(this.targetEntity.position);
                    if (dist > this.range) {
                        this.moveTo(this.targetEntity.position, dt);
                    } else {
                        if (this.attackCooldown <= 0) {
                            this.targetEntity.takeDamage(this.attackDamage);
                            this.attackCooldown = this.attackTimerMax;
                        }
                    }
                }
                else if (this.state === 'CONSTRUCT' && this.targetPos) {
                    const dist = this.position.distanceTo(this.targetPos);
                    if (dist > 2) {
                        this.moveTo(this.targetPos, dt);
                    } else {
                        this.constructTimer += dt;
                        this.mesh.rotation.y = Math.sin(Date.now() * 0.015) * 0.5;
                        
                        const buildTime = CONFIG.ENTITIES[this.constructType].time;
                        
                        if (this.constructTimer >= buildTime) {
                            GameLogic.createBuilding(this.constructType, this.owner, this.targetPos);
                            if (this.temporaryFoundationMesh) { scene.remove(this.temporaryFoundationMesh); }
                            
                            if (this.owner === 'enemy') {
                                if (this.constructType === CONFIG.ENTITIES.House.type) state.aiMemory.buildingHouse = false;
                                if (this.constructType === CONFIG.ENTITIES.Barracks.type) state.aiMemory.buildingBarracks = false;
                            }
                            
                            this.state = 'IDLE';
                            this.constructType = null;
                            this.constructTimer = 0;
                            this.constructCost = null;
                            this.mesh.rotation.y = 0;
                        }
                    }
                }

                // Separation
                const neighbors = state.entities.filter(e => e !== this && e instanceof Unit && !e.dead && e.position.distanceTo(this.position) < 2.5);
                if (neighbors.length > 0) {
                    const sep = new THREE.Vector3();
                    neighbors.forEach(n => sep.add(new THREE.Vector3().subVectors(this.position, n.position).normalize()));
                    this.position.add(sep.multiplyScalar(dt * 5));
                    this.syncMesh();
                }
            }

            remove() {
                if (this.state === 'CONSTRUCT' && this.constructCost) {
                    GameLogic.addResource(this.owner, 'wood', this.constructCost.wood || 0);
                    if (this.owner === 'player') UI.notify("Builder died! Resources refunded.");
                    if (this.temporaryFoundationMesh) scene.remove(this.temporaryFoundationMesh);
                }
                super.remove();
            }

            moveTo(target, dt) {
                const dir = new THREE.Vector3().subVectors(target, this.position).normalize();
                dir.y = 0;
                this.position.add(dir.multiplyScalar(this.speed * dt));
                this.syncMesh();
                this.mesh.lookAt(target);
            }
            
            syncMesh() {
                this.mesh.position.copy(this.position);
                this.mesh.position.y = CONFIG.ENTITIES[this.type].height / 2;
                this.selectionRing.position.copy(this.position);
                this.selectionRing.position.y = 0.1;
            }

            setSelected(bool) {
                this.selectionRing.visible = bool;
                this.showHealthBar(bool);
            }
        }

        class Building extends Entity {
            constructor(type, owner, position) {
                super(type, owner, position);
                
                this.productionQueue = [];
                this.productionTimer = 0;
                this.isProducing = false;

                const faction = owner === 'player' ? "kingdom" : "enemy";
                const color = owner === 'player' ? CONFIG.COLORS.PLAYER_BUILDING : CONFIG.COLORS.ENEMY_BUILDING;
                this.mesh = AssetFactory.create(type, faction, color);
                this.mesh.position.copy(position);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.userData = { entity: this };
                scene.add(this.mesh);
                
                this.uiUpdateTimer = Date.now();
                
                const stats = CONFIG.ENTITIES[type];
                if (stats && stats.popBonus > 0) {
                    if (owner === 'player') state.playerMaxPop += stats.popBonus;
                    else state.enemyMaxPop += stats.popBonus;
                    UI.update();
                }
            }

            update(dt) {
                const screenPos = this.position.clone().project(camera);
                const x = (screenPos.x + 1) / 2 * window.innerWidth;
                const y = -(screenPos.y - 1) / 2 * window.innerHeight;
                this.hpBarEl.style.left = x + 'px';
                this.hpBarEl.style.top = (y - 40) + 'px';

                if (this.productionQueue.length > 0) {
                    this.isProducing = true;
                    this.productionTimer += dt;

                    const currentItem = this.productionQueue[0];
                    const timeNeeded = CONFIG.ENTITIES[currentItem.type].time;

                    if (this.isProducing) {
                        const s = 1 + Math.sin(Date.now()*0.005) * 0.02;
                        this.mesh.scale.set(s,s,s);
                    }

                    if (this.productionTimer >= timeNeeded) {
                        const pop = this.owner === 'player' ? state.playerPop : state.enemyPop;
                        const max = this.owner === 'player' ? state.playerMaxPop : state.enemyMaxPop;

                        if (pop < max) {
                            const spawnPos = this.position.clone().add(new THREE.Vector3(0, 0, 8));
                            const spawnedUnit = GameLogic.createUnit(currentItem.type, this.owner, spawnPos);
                            if (this.gatherPointPos) {
                                spawnedUnit.state = 'MOVE'; spawnedUnit.targetPos = this.gatherPointPos;
                            }

                            this.productionQueue.shift();
                            this.productionTimer = 0;

                            if (this.productionQueue.length === 0) {
                                this.isProducing = false;
                                this.mesh.scale.setScalar(1);
                            }
                            if (state.selection.includes(this)) UI.updateSelection();
                        } else {
                            if (this.owner === 'player' && Date.now() - this.uiUpdateTimer > 2000) {
                                UI.notify("Population Full! Build House.");
                                this.uiUpdateTimer = Date.now();
                            }
                        }
                    }
                    
                    const now = Date.now();
                    if (now - this.uiUpdateTimer > 500) {
                        if (state.selection.includes(this)) UI.updateSelection();
                        this.uiUpdateTimer = now;
                    }
                } else {
                     this.mesh.scale.setScalar(1);
                }
            }

            addToQueue(type, cost, owner) {
                this.productionQueue.push({ type, cost, owner });
            }
            
            setSelected(bool) {
                this.showHealthBar(bool);
            }
        }

        class Resource extends Entity {
            constructor(type, position) {
                super(type, 'gaia', position);
                let color, geo;
                if (type === 'Tree') {
                    color = 0x2e8b57; geo = new THREE.ConeGeometry(1.5, 6, 8); this.meshType = 'wood';
                } else if (type === 'GoldMine') {
                    color = 0xffd700; geo = new THREE.DodecahedronGeometry(2.5); this.meshType = 'gold';
                } else if (type === 'BerryBush') {
                    color = 0xff6347; geo = new THREE.SphereGeometry(1.5, 8, 8); this.meshType = 'food';
                } else if (type === 'OilSeep') {
                    color = 0x111111; geo = new THREE.CylinderGeometry(3, 3, 0.5, 16); this.meshType = 'oil';
                }
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(position);
                this.mesh.position.y = type === 'Tree' ? 3 : (type === 'OilSeep' ? 0.25 : 1.5);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.userData = { entity: this };
                scene.add(this.mesh);
            }
            update(dt) {}
        }

        // --- 6. GAME LOGIC (STATE MANAGEMENT) ---
        const GameLogic = {
            findNearestBuilding: function(owner, type) {
                let nearest = null; let minDist = Infinity;
                state.entities.forEach(e => {
                    if (e.owner === owner && e.type === type && !e.dead) {
                        const d = e.position.distanceTo(this ? this.position : new THREE.Vector3(0,0,0));
                        if (d < minDist) { minDist = d; nearest = e; }
                    }
                });
                return nearest;
            },

            findNearestResource: function(pos, type) {
                let nearest = null; let minDist = Infinity;
                state.entities.forEach(e => {
                    if ((type ? e.meshType === type : true) && !e.dead) {
                        const d = e.position.distanceTo(pos);
                        if (d < minDist) { minDist = d; nearest = e; }
                    }
                });
                return nearest;
            },

            addResource: function(owner, type, amount) {
                if (!type || type === 'oil') return; 
                const res = owner === 'player' ? state.playerResources : state.enemyResources;
                if (res[type] !== undefined) {
                    res[type] += amount;
                    if (owner === 'player') UI.update();
                }
            },

            createUnit: function(type, owner, pos) {
                const pop = owner === 'player' ? state.playerPop : state.enemyPop;
                const max = owner === 'player' ? state.playerMaxPop : state.enemyMaxPop;
                
                if (pop >= max) { 
                    if (owner === 'player') UI.notify("Population Limit Reached!"); 
                    return; 
                }
                
                const u = new Unit(type, owner, pos);
                state.entities.push(u);
                if (owner === 'player') state.playerPop++;
                else state.enemyPop++;
                UI.update();
                return u;
            },

            createBuilding: function(type, owner, pos) {
                const b = new Building(type, owner, pos);
                state.entities.push(b);
            },

            createResource: function(type, pos) {
                state.entities.push(new Resource(type, pos));
            },

            trainUnit: function(building, unitType, cost, owner) {
                const res = owner === 'player' ? state.playerResources : state.enemyResources;
                if (res.food < (cost.food||0) || res.gold < (cost.gold||0) || res.wood < (cost.wood||0)) {
                    if (owner === 'player') UI.notify("Insufficient Resources!");
                    return false;
                }

                res.food -= (cost.food||0);
                res.gold -= (cost.gold||0);
                res.wood -= (cost.wood||0);
                if (owner === 'player') UI.update();

                building.addToQueue(unitType, cost, owner);
                return true;
            },
            
            initGame: function(mapSize = 200) {
                const mapGen = new MapGenerator({ mapSize: mapSize });
                mapGen.generate();
                
                const tc = this.findNearestBuilding('enemy', CONFIG.ENTITIES.TownCenter.type);
                if(tc) enemyAI = new CityPlanner(tc.position);

                state.isPlaying = true;
                animate();
                setInterval(AI.tick, CONFIG.AI_THINK_INTERVAL);
            }
        };

        // --- 7. MAP GENERATION ---
        class MapGenerator {
            constructor(settings) {
                this.settings = settings;
                this.usedPositions = [];
            }
            
            generate() {
                const size = this.settings.mapSize;
                
                const fullSize = size * 2;
                const groundGeo = new THREE.PlaneGeometry(fullSize, fullSize);
                const groundMat = new THREE.MeshStandardMaterial({ color: CONFIG.COLORS.GROUND });
                ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                ground.name = "Ground";
                scene.add(ground);
                
                const mygrid = new THREE.GridHelper(fullSize, fullSize/10, 0x000000, 0x000000);
                mygrid.material.opacity = 0.1;
                mygrid.material.transparent = true;
                scene.add(mygrid);
                grid = mygrid;

                this.setupPlayer('player', new THREE.Vector3(-50, 0, -50));
                this.setupPlayer('enemy', new THREE.Vector3(50, 0, 50));

                for(let i=0; i<30; i++) this.spawnRandomResource('Tree', 80);
                for(let i=0; i<4; i++) this.spawnRandomResource('GoldMine', 150);
                for(let i=0; i<4; i++) this.spawnRandomResource('BerryBush', 150);
            }

            setupPlayer(owner, pos) {
                GameLogic.createBuilding(CONFIG.ENTITIES.TownCenter.type, owner, pos);
                GameLogic.createUnit(CONFIG.ENTITIES.Villager.type, owner, pos.clone().add(new THREE.Vector3(5, 0, 5)));
                GameLogic.createUnit(CONFIG.ENTITIES.Villager.type, owner, pos.clone().add(new THREE.Vector3(-5, 0, 5)));
                GameLogic.createUnit(CONFIG.ENTITIES.Soldier.type, owner, pos.clone().add(new THREE.Vector3(0, 0, -8)));
            }

            spawnRandomResource(type, margin) {
                let pos, valid;
                let attempts = 0;
                do {
                    const range = this.settings.mapSize - margin;
                    pos = new THREE.Vector3((Math.random()-0.5)*2*range, 0, (Math.random()-0.5)*2*range);
                    valid = true;
                    for(let used of this.usedPositions) {
                        if(used.distanceTo(pos) < 10) valid = false;
                    }
                    attempts++;
                } while(!valid && attempts < 50);
                
                if(valid) {
                    this.usedPositions.push(pos);
                    GameLogic.createResource(type, pos);
                }
            }
        }

        class CityPlanner {
            constructor(townCenterPosition) {
                this.tc = townCenterPosition;
                this.occupied = [];
                this.ring = 0;
            }
            
            planLocation(type) {
                const size = type === CONFIG.ENTITIES.House.type ? 5 : 8;
                for(let r = 10; r < 100; r += 5) {
                    for(let theta = 0; theta < Math.PI * 2; theta += 0.5) {
                        const x = Math.cos(theta) * r;
                        const z = Math.sin(theta) * r;
                        const pos = new THREE.Vector3(x, 0, z).add(this.tc);
                        
                        let collision = false;
                        for(let entity of state.entities) {
                            if (entity.position.distanceTo(pos) < size + 4) collision = true;
                        }
                        
                        if(!collision) return pos.clone().sub(this.tc);
                    }
                }
                return new THREE.Vector3(10, 0, 10);
            }
        }

        let enemyAI = null;

        // --- 8. AI SYSTEM ---
        const AI = {
            rules: [
                {
                    name: "Build House",
                    condition: () => {
                        const pop = state.enemyPop;
                        const max = state.enemyMaxPop;
                        return (pop + 2 >= max) && !state.aiMemory.buildingHouse && state.enemyResources.wood >= 30;
                    },
                    action: () => {
                        const villager = GameLogic.findNearestBuilding('enemy', CONFIG.ENTITIES.Villager.type); // Hack: findVillager is specific, reusing generic find
                        // Better: find actual idle villager
                        const v = state.entities.find(e => e.owner === 'enemy' && e.type === CONFIG.ENTITIES.Villager.type && !e.dead && e.state === 'IDLE');
                        const tc = GameLogic.findNearestBuilding('enemy', CONFIG.ENTITIES.TownCenter.type);
                        
                        if (v && tc && enemyAI) {
                            const spot = tc.position.clone().add(enemyAI.planLocation(CONFIG.ENTITIES.House.type));
                            state.enemyResources.wood -= 30;
                            v.state = 'CONSTRUCT';
                            v.targetPos = spot;
                            v.constructType = CONFIG.ENTITIES.House.type;
                            v.constructTimer = 0;
                            v.constructCost = { wood: 30 };
                            state.aiMemory.buildingHouse = true;
                        }
                    }
                },
                {
                    name: "Train Villager",
                    condition: () => {
                        const tc = GameLogic.findNearestBuilding('enemy', CONFIG.ENTITIES.TownCenter.type);
                        return tc && tc.productionQueue.length < 2 && state.enemyResources.food >= 50;
                    },
                    action: () => {
                        const tc = GameLogic.findNearestBuilding('enemy', CONFIG.ENTITIES.TownCenter.type);
                        if (tc) GameLogic.trainUnit(tc, CONFIG.ENTITIES.Villager.type, CONFIG.ENTITIES.Villager.cost, 'enemy');
                    }
                },
                {
                    name: "Assign Idle Villagers",
                    condition: () => {
                        return state.entities.find(e => e.owner === 'enemy' && e.type === CONFIG.ENTITIES.Villager.type && !e.dead && e.state === 'IDLE') !== undefined;
                    },
                    action: () => {
                        const v = state.entities.find(e => e.owner === 'enemy' && e.type === CONFIG.ENTITIES.Villager.type && !e.dead && e.state === 'IDLE');
                        if (!v) return;
                        
                        let allResType = [
                            { type: 'wood', rate: 0.5 * state.aiMemory.gatherRate.wood }, 
                            { type: 'food', rate: 0.33 * state.aiMemory.gatherRate.food }, 
                            { type: 'gold', rate: 1 * state.aiMemory.gatherRate.gold }
                        ];
                        allResType.sort((a, b) => a.rate - b.rate);

                        let target = null;
                        let resType = 'food';
                        for (let res of allResType) {
                            target = GameLogic.findNearestResource(v.position, res.type);
                            if (target) {
                                resType = res.type;
                                break;
                            }
                        }
                        
                        if (target) {
                            v.state = 'GATHER';
                            v.targetEntity = target;
                            v.gatherType = resType;
                            state.aiMemory.gatherRate[resType]++;
                        }
                    }
                }
            ],
            tick: function() {
                if (!state.isPlaying) return;
                const now = Date.now();
                if (now - state.aiMemory.lastActionTime < CONFIG.AI_APM_LIMIT) return;

                for (let rule of this.rules) {
                    if (rule.condition()) {
                        rule.action();
                        state.aiMemory.lastActionTime = now;
                        break;
                    }
                }
            }
        };

        // --- 9. INPUT HANDLING ---
        const Input = {
            raycaster: new THREE.Raycaster(),
            mouse: new THREE.Vector2(),
            isDragging: false,
            dragStart: new THREE.Vector2(),

            init: function() {
                const canvas = renderer.domElement;
                const selectionBoxDiv = document.getElementById('selection-box');

                window.addEventListener('keydown', (e) => {
                    state.keysPressed[e.key] = true;
                    if (!state.isPlaying) return;
                    const k = e.key.toLowerCase();
                    
                    if (k === '.') UI.selectAllIdleVillagers();
                    if (k === 'escape') {
                        if (state.buildingMode) this.cancelBuildingMode();
                        else UI.clearSelection();
                    }
                    
                    const first = state.selection[0];
                    if (first && first instanceof Unit && first.type === CONFIG.ENTITIES.Villager.type) {
                        if (k === 'h') this.startBuildingMode(CONFIG.ENTITIES.House.type, CONFIG.ENTITIES.House.cost);
                        if (k === 'b') this.startBuildingMode(CONFIG.ENTITIES.Barracks.type, CONFIG.ENTITIES.Barracks.cost);
                    }
                    if (first && first instanceof Building) {
                        if (first.type === CONFIG.ENTITIES.TownCenter.type && k === 'v') 
                            GameLogic.trainUnit(first, CONFIG.ENTITIES.Villager.type, CONFIG.ENTITIES.Villager.cost, 'player');
                        if (first.type === CONFIG.ENTITIES.Barracks.type && k === 's') 
                            GameLogic.trainUnit(first, CONFIG.ENTITIES.Soldier.type, CONFIG.ENTITIES.Soldier.cost, 'player');
                    }
                });

                window.addEventListener('keyup', (e) => state.keysPressed[e.key] = false);

                // Central UI Event Handler
                document.getElementById('ui-layer').addEventListener('mouseup', (e) => {
                    let clickedBtn = e.target.closest('button');
                    if (clickedBtn) {
                        const route = clickedBtn.getAttribute('data-ui-route-type');
                        const key = clickedBtn.getAttribute('data-ui-hotkey');
                        if (route === 'ActionButton') {
                            const first = state.selection[0];
                            if (!first) return;
                            const k = key.toLowerCase();
                            
                            if (first instanceof Building) {
                                if (first.type === CONFIG.ENTITIES.TownCenter.type && k === 'v') 
                                    GameLogic.trainUnit(first, CONFIG.ENTITIES.Villager.type, CONFIG.ENTITIES.Villager.cost, 'player');
                                if (first.type === CONFIG.ENTITIES.Barracks.type && k === 's') 
                                    GameLogic.trainUnit(first, CONFIG.ENTITIES.Soldier.type, CONFIG.ENTITIES.Soldier.cost, 'player');
                            } else if (first instanceof Unit && first.type === CONFIG.ENTITIES.Villager.type) {
                                if (k === 'h') this.startBuildingMode(CONFIG.ENTITIES.House.type, CONFIG.ENTITIES.House.cost);
                                if (k === 'b') this.startBuildingMode(CONFIG.ENTITIES.Barracks.type, CONFIG.ENTITIES.Barracks.cost);
                            }
                        }
                    }
                }, true);

                canvas.addEventListener('mousedown', (e) => {
                    if (e.target.closest('#ui-layer')) return;
                    if (e.button !== 0) return;
                    if (state.buildingMode) {
                        this.confirmBuildPlacement();
                        return;
                    }

                    this.isDragging = true;
                    const rect = canvas.getBoundingClientRect();
                    this.dragStart.set(e.clientX - rect.left, e.clientY - rect.top);
                    selectionBoxDiv.style.left = this.dragStart.x + 'px';
                    selectionBoxDiv.style.top = this.dragStart.y + 'px';
                    selectionBoxDiv.style.width = '0px';
                    selectionBoxDiv.style.height = '0px';
                    selectionBoxDiv.style.display = 'block';

                    if (!e.shiftKey) UI.clearSelection();
                });

                window.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    if (state.buildingMode) {
                        this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                        this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                        this.raycaster.setFromCamera(this.mouse, camera);
                        const intersects = this.raycaster.intersectObject(ground);
                        if (intersects.length > 0) state.ghostMesh.position.copy(intersects[0].point);
                        return;
                    }

                    if (this.isDragging) {
                        const currentX = e.clientX - rect.left;
                        const currentY = e.clientY - rect.top;
                        const w = Math.abs(currentX - this.dragStart.x);
                        const h = Math.abs(currentY - this.dragStart.y);
                        const l = Math.min(currentX, this.dragStart.x);
                        const t = Math.min(currentY, this.dragStart.y);
                        selectionBoxDiv.style.width = w + 'px';
                        selectionBoxDiv.style.height = h + 'px';
                        selectionBoxDiv.style.left = l + 'px';
                        selectionBoxDiv.style.top = t + 'px';
                    }
                });

                window.addEventListener('mouseup', (e) => {
                    if (e.button !== 0) return;
                    if (state.buildingMode) return;
                    if (e.target.closest('#ui-layer')) return;
                    
                    this.isDragging = false;
                    selectionBoxDiv.style.display = 'none';

                    const rect = canvas.getBoundingClientRect();
                    const dragEnd = new THREE.Vector2(e.clientX - rect.left, e.clientY - rect.top);
                    const dist = this.dragStart.distanceTo(dragEnd);

                    if (dist < 5) {
                        this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                        this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                        this.raycaster.setFromCamera(this.mouse, camera);
                        const intersects = this.raycaster.intersectObjects(scene.children, true);
                        let clickedEntity = null;
                        for (let hit of intersects) {
                            if (hit.object.userData.entity) {
                                clickedEntity = hit.object.userData.entity;
                                break;
                            }
                            if (hit.object.parent && hit.object.parent.userData.entity) {
                                clickedEntity = hit.object.parent.userData.entity;
                                break;
                            }
                        }
                        UI.selectEntity(clickedEntity, e.shiftKey);
                    } else {
                        UI.boxSelection(this.dragStart, dragEnd);
                    }
                });

                window.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (state.buildingMode) { this.cancelBuildingMode(); return; }
                    if (state.selection.length === 0) return;

                    const rect = canvas.getBoundingClientRect();
                    this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    this.raycaster.setFromCamera(this.mouse, camera);
                    const intersects = this.raycaster.intersectObjects(scene.children, true);

                    let targetEntity = null;
                    let groundPoint = null;
                    for (let hit of intersects) {
                        if (hit.object.userData.entity) { targetEntity = hit.object.userData.entity; break; }
                        else if (hit.object.parent && hit.object.parent.userData.entity) { targetEntity = hit.object.parent.userData.entity; break; }
                        else if (hit.object.name === "Ground") { groundPoint = hit.point; }
                    }

                    let firstUnit = true;
                    state.selection.forEach(unit => {
                        if (unit instanceof Unit) {
                            if (targetEntity) {
                                if (targetEntity.owner === 'enemy') {
                                    unit.state = 'ATTACK'; unit.targetEntity = targetEntity;
                                } else if (targetEntity instanceof Resource) {
                                    unit.state = 'GATHER'; unit.targetEntity = targetEntity; unit.gatherType = targetEntity.meshType;
                                } else {
                                    unit.state = 'MOVE'; unit.targetPos = targetEntity.position;
                                }
                            } else if (groundPoint) {
                                unit.state = 'MOVE'; unit.targetPos = groundPoint;
                                Effects.createClickMarker(groundPoint);
                            }
                            if (firstUnit) { Sound.tts(Script.getVoiceOverLine('unitCommand', { action: unit.state, target: targetEntity }) ); }
                        }
                        if (unit instanceof Building) {
                            if (groundPoint) {
                                unit.gatherPointPos = groundPoint;
                                Effects.createClickMarker(groundPoint);
                            }
                        }
                        firstUnit = false;
                    });
                });
            },

            startBuildingMode: function(type, cost) {
                if (state.playerResources.wood < (cost.wood||0)) { UI.notify("Not enough Wood!"); return; }
                state.playerResources.wood -= (cost.wood||0);
                UI.update();

                state.buildingMode = { type, cost };
                
                const mat = new THREE.MeshBasicMaterial({ color: CONFIG.COLORS.GHOST, transparent: true, opacity: 0.5, wireframe: true });
                state.ghostMesh = AssetFactory.create(type, "kingdom", CONFIG.COLORS.GHOST, mat);
                scene.add(state.ghostMesh);
            },

            confirmBuildPlacement: function() {
                if (!state.buildingMode) return;
                const pos = state.ghostMesh.position.clone();
                pos.y = 0;
                
                let builder = null;
                
                if (state.selection.length > 0 && state.selection[0] instanceof Unit && state.selection[0].type === CONFIG.ENTITIES.Villager.type) {
                    builder = state.selection[0];
                }
                
                if (!builder) {
                    let minDist = Infinity;
                    state.entities.forEach(e => {
                        if (e instanceof Unit && e.owner === 'player' && e.type === CONFIG.ENTITIES.Villager.type && e.state === 'IDLE') {
                            const d = e.position.distanceTo(pos);
                            if (d < minDist) { minDist = d; builder = e; }
                        }
                    });
                }

                if (builder) {
                    builder.state = 'CONSTRUCT';
                    builder.targetPos = pos;
                    builder.constructType = state.buildingMode.type;
                    builder.constructTimer = 0;
                    builder.constructCost = state.buildingMode.cost;

                    let w = 8, h = 0.4, d = 8;
                    if (state.buildingMode.type === CONFIG.ENTITIES.House.type) { w=5; d=5; }
                    
                    const geometry = new THREE.BoxGeometry(w, h, d);
                    const material = new THREE.MeshStandardMaterial({ color: CONFIG.COLORS.FOUNDATION });
                    const foundationMesh = new THREE.Mesh(geometry, material);
                    foundationMesh.position.copy(pos);
                    foundationMesh.position.y = h/2;
                    scene.add(foundationMesh);
                    builder.temporaryFoundationMesh = foundationMesh;
                    
                    this.cancelBuildingModeUI();
                } else {
                    UI.notify("Need an Idle Villager to build!");
                    state.playerResources.wood += state.buildingMode.cost.wood || 0;
                    UI.update();
                    this.cancelBuildingMode();
                }
            },

            cancelBuildingModeUI: function() {
                if (state.ghostMesh) scene.remove(state.ghostMesh);
                state.ghostMesh = null;
                state.buildingMode = null;
            },

            cancelBuildingMode: function() {
                if (state.buildingMode) {
                    state.playerResources.wood += state.buildingMode.cost.wood || 0;
                    UI.update();
                    UI.notify("Build Cancelled");
                }
                this.cancelBuildingModeUI();
            }
        };

        // --- 10. UI CONTROLLER ---
        const UI = {
            update: function() {
                document.getElementById('res-wood').innerText = Math.floor(state.playerResources.wood);
                document.getElementById('res-food').innerText = Math.floor(state.playerResources.food);
                document.getElementById('res-gold').innerText = Math.floor(state.playerResources.gold);
                document.getElementById('res-oil').innerText = Math.floor(state.playerResources.oil);
                document.getElementById('res-pop').innerText = state.playerPop;
                document.getElementById('res-max-pop').innerText = state.playerMaxPop;
            },

            updateSelection: function() {
                const nameEl = document.getElementById('selection-name');
                const statsEl = document.getElementById('selection-stats');
                const queueEl = document.getElementById('queue-info');
                const grid = document.getElementById('actions-grid');
                grid.innerHTML = '';

                if (state.selection.length === 0) {
                    nameEl.innerText = "Nothing Selected";
                    statsEl.innerText = "";
                    queueEl.innerText = "";
                    return;
                }

                const first = state.selection[0];
                if (state.selection.length > 1) {
                    nameEl.innerText = `${state.selection.length} Units`;
                    statsEl.innerText = "Ready";
                    queueEl.innerText = "";
                } else {
                    nameEl.innerText = first.type;
                    statsEl.innerText = `HP: ${Math.floor(first.hp)}/${first.maxHp}`;
                    queueEl.innerText = "";

                    if (first instanceof Building) {
                        if (first.productionQueue.length > 0) {
                            const current = first.productionQueue[0];
                            const timeNeeded = CONFIG.ENTITIES[current.type].time;
                            const pct = Math.min(100, (first.productionTimer / timeNeeded) * 100);
                            queueEl.innerText = `Producing: ${current.type} (${first.productionQueue.length}) [${Math.floor(pct)}%]`;
                        } else {
                            queueEl.innerText = "Idle";
                        }

                        if (first.type === CONFIG.ENTITIES.TownCenter.type) this.createActionButton('Train Villager', '50 Food', 'V');
                        if (first.type === CONFIG.ENTITIES.Barracks.type) this.createActionButton('Train Soldier', '60F / 20G', 'S');
                    }
                    
                    if (first instanceof Unit && first.type === CONFIG.ENTITIES.Villager.type) {
                        this.createActionButton('Build House', '30 Wood', 'H');
                        this.createActionButton('Build Barracks', '150 Wood', 'B');
                    }
                }
            },

            createActionButton: function(label, cost, key) {
                const btn = document.createElement('button');
                btn.className = 'action-btn';
                btn.innerHTML = `<span>${label}</span><span class="cost-tooltip">${cost}</span><span class="hotkey">${key}</span>`;
                btn.setAttribute('data-ui-route-type', 'ActionButton');
                btn.setAttribute('data-ui-hotkey', key);
                document.getElementById('actions-grid').appendChild(btn);
            },

            selectEntity: function(entity, additive) {
                if (!additive) this.clearSelection();
                if (entity && entity.owner === 'player') {
                    if (!state.selection.includes(entity)) {
                        state.selection.push(entity);
                        entity.setSelected(true);
                    }
                    if (entity instanceof Unit) Sound.tts(Script.getVoiceOverLine('selectUnit', entity.type));
                }
                this.updateSelection();
            },

            boxSelection: function(start, end) {
                this.clearSelection();
                const left = Math.min(start.x, end.x);
                const right = Math.max(start.x, end.x);
                const top = Math.min(start.y, end.y);
                const bottom = Math.max(start.y, end.y);

                state.entities.forEach(entity => {
                    if (entity instanceof Unit && entity.owner === 'player') {
                        const screenPos = entity.position.clone().project(camera);
                        const x = (screenPos.x + 1) / 2 * window.innerWidth;
                        const y = -(screenPos.y - 1) / 2 * window.innerHeight;
                        if (x >= left && x <= right && y >= top && y <= bottom) {
                            state.selection.push(entity);
                            entity.setSelected(true);
                        }
                    }
                });
                this.updateSelection();
            },

            selectAllIdleVillagers: function() {
                this.clearSelection();
                state.entities.forEach(e => {
                    if (e instanceof Unit && e.owner === 'player' && e.type === CONFIG.ENTITIES.Villager.type && e.state === 'IDLE') {
                        state.selection.push(e);
                        e.setSelected(true);
                    }
                });
                this.updateSelection();
                if (state.selection.length > 0) { this.notify(`Selected ${state.selection.length} idle villagers`); }
                else { this.notify(`No idle villagers`); }
            },

            clearSelection: function() {
                state.selection.forEach(e => e.setSelected(false));
                state.selection = [];
                this.updateSelection();
            },

            notify: function(msg) {
                const area = document.getElementById('notification-area');
                const t = document.createElement('div');
                t.className = 'toast';
                t.innerText = msg;
                area.appendChild(t);
                setTimeout(() => t.remove(), 3000);
            }
        };

        // --- 11. EFFECTS & SOUND ---
        const Effects = {
            createClickMarker: function(pos) {
                const geo = new THREE.RingGeometry(0.5, 1, 16);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.position.y += 0.2;
                mesh.rotation.x = -Math.PI / 2;
                scene.add(mesh);
                let scale = 1;
                function anim() {
                    scale -= 0.05;
                    mesh.scale.setScalar(scale);
                    mat.opacity = scale;
                    if (scale > 0) requestAnimationFrame(anim);
                    else scene.remove(mesh);
                }
                anim();
            },

            showFloatText: function(text, pos) {
                const div = document.createElement('div');
                div.innerText = text;
                div.style.position = 'absolute';
                div.style.color = '#fff';
                div.style.fontWeight = 'bold';
                div.style.fontSize = '16px';
                div.style.textShadow = '1px 1px 0 #000';
                div.style.pointerEvents = 'none';
                div.style.transition = 'top 1s, opacity 1s';
                document.body.appendChild(div);

                const screenPos = pos.clone().project(camera);
                const x = (screenPos.x + 1) / 2 * window.innerWidth;
                const y = -(screenPos.y - 1) / 2 * window.innerHeight;

                div.style.left = x + 'px';
                div.style.top = y + 'px';

                requestAnimationFrame(() => {
                    div.style.top = (y - 50) + 'px';
                    div.style.opacity = 0;
                });
                setTimeout(() => div.remove(), 1000);
            }
        };

        const Sound = {
            synth: window.speechSynthesis,
            voices: [],
            init: function() {
                if (speechSynthesis.onvoiceschanged !== undefined) {
                    speechSynthesis.onvoiceschanged = () => { this.voices = this.synth.getVoices(); };
                }
            },
            tts: function(prompt) {
                if (this.synth.speaking) this.synth.cancel();
                const utter = new SpeechSynthesisUtterance(prompt);
                utter.voice = this.voices.find(v => v.default) || this.voices[0];
                utter.pitch = 1.0; utter.rate = 1.2;
                this.synth.speak(utter);
            }
        };
        Sound.init();

        const Script = {
            randomSelect: function(array) { return array[Math.floor(Math.random() * array.length)]; },
            getVoiceOverLine: function(event, data) {
                if (event == 'selectUnit') {
                    if (data == CONFIG.ENTITIES.Villager.type) return this.randomSelect(["Yes?", "How may I help?", "At your service!"]);
                    if (data == CONFIG.ENTITIES.Soldier.type) return this.randomSelect(["My Lord", "Ready for battle.", "At your command!"]);
                }
                if (event == 'unitCommand') {
                    if (data['action'] == 'ATTACK') return this.randomSelect(["Attack!", "Charge!", "For the King!"]);
                    if (data['action'] == 'GATHER') return "Gathering resources.";
                    if (data['action'] == 'MOVE') return this.randomSelect(["Moving.", "As you wish."]);
                }
                return "";
            }
        };

        // --- 12. MAIN LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            
            // Camera Panning
            const panSpeed = 50 * dt;
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0; forward.normalize();
            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();

            if (state.keysPressed['ArrowUp']) {
                camera.position.add(forward.multiplyScalar(panSpeed));
                controls.target.add(forward);
            }
            if (state.keysPressed['ArrowDown']) {
                camera.position.add(forward.multiplyScalar(-panSpeed));
                controls.target.add(forward);
            }
            if (state.keysPressed['ArrowLeft']) {
                camera.position.add(right.multiplyScalar(-panSpeed));
                controls.target.add(right);
            }
            if (state.keysPressed['ArrowRight']) {
                camera.position.add(right.multiplyScalar(panSpeed));
                controls.target.add(right);
            }

            state.entities = state.entities.filter(e => !e.dead);
            state.entities.forEach(e => e.update(dt));
            
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 13. ENTRY POINT ---
        window.startGame = function() {
            document.getElementById('start-screen').style.display = 'none';
            Input.init(); // Initialize listeners once
            GameLogic.initGame();
        };

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect; camera.right = d * aspect;
            camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
```

### Global Variable Lifecycle Analysis

To implement a **Game Restart / End** feature in the future, you must explicitly reset or handle the following global variables. If you just change a level or restart without touching these, bugs (ghost units, incorrect resources, memory leaks) will occur.

1.  **`state` Object**: The most critical container.
    *   **`state.playerResources` / `state.enemyResources`**: Must be reset to initial values (200 wood/food, etc.).
    *   **`state.playerPop` / `state.enemyPop`**: Must be reset to 0.
    *   **`state.entities`**: **Crucial**. The array must be cleared. However, merely `state.entities = []` is risky because the Three.js meshes and HTML HP bars inside those entities will persist in memory/DOM.
        *   *Safe Reset Strategy*: Iterate through `state.entities` and call `entity.remove()` on every single one before emptying the array. This ensures 3D meshes and DOM elements are cleaned up.
    *   **`state.selection`**: Must be emptied.

2.  **Three.js Scene & Globals**:
    *   **`scene.children`**: When entities are removed via `entity.remove()`, they detach from the scene. However, the Ground plane (`ground`) and Grid (`grid`) are added directly.
        *   *Restart Strategy*: If you want to regenerate the map, you must `scene.remove(ground)` and `scene.remove(grid)` before generating a new map.

3.  **Game Logic / AI State**:
    *   **`state.aiMemory`**: Must be reset (building flags, gather rates).
    *   **`enemyAI`**: This is an instance of `CityPlanner`. It contains `occupied` coordinates based on the old map.
        *   *Restart Strategy*: You must either re-instantiate `enemyAI = new CityPlanner(...)` or clear its internal `occupied` array.

4.  **Timers**:
    *   **`setInterval`**: In the current code, `setInterval` is stored anonymously inside `GameLogic.initGame` and `AI.tick`.
        *   *Risk*: If you call `initGame` twice without clearing the old interval, the AI will think twice as fast (or four times, etc.).
        *   *Fix*: Store the interval ID (e.g., `let aiIntervalId;`) and call `clearInterval(aiIntervalId)` at the start of a reset function.

5.  **Input State**:
    *   **`state.keysPressed`**: Should be cleared to prevent stuck movement.
    *   **`state.buildingMode`**: Must be set to `null` to clear ghost meshes if the player was placing a building when the game ended.

6.  **Camera**:
    *   **`camera.position`** and **`controls.target`**: If the camera has moved far away in the previous game, it should probably be reset to a default position upon restart.

**Summary for a Future `resetGame()` function:**
```javascript
function resetGame() {
    // 1. Stop Loops
    clearInterval(aiIntervalId);
    
    // 2. Clean Entities (Iterative)
    state.entities.forEach(e => e.remove());
    state.entities = [];
    
    // 3. Reset State Data
    state.playerResources = { ...initialResources };
    state.playerPop = 0;
    state.selection = [];
    state.aiMemory = { ...initialAiMemory };
    state.buildingMode = null;
    
    // 4. Clean Scene (Map specific)
    scene.remove(ground);
    scene.remove(grid);
    
    // 5. Reset Camera
    camera.position.set(100, 100, 100);
    controls.target.set(0,0,0);
    
    // 6. Restart
    GameLogic.initGame();
}
```

