<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Age of Empires 3D Prototype (v5 - Queues & Construction)</title>
    <style>
        :root {
            --ui-bg: rgba(20, 20, 30, 0.95);
            --ui-border: #8b7e66;
            --ui-text: #f0e6d2;
            --accent: #d4af37;
            --danger: #ff4444;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #resource-bar, #control-panel, .action-btn, .res-item {
            pointer-events: auto;
        }

        /* Top Resource Bar */
        #resource-bar {
            background: var(--ui-bg);
            border-bottom: 2px solid var(--ui-border);
            padding: 8px 20px;
            display: flex;
            gap: 20px;
            color: var(--ui-text);
            font-weight: bold;
            font-size: 1rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .res-item { display: flex; align-items: center; gap: 6px; }
        .res-icon { font-size: 1.2rem; }

        /* Bottom Control Panel */
        #control-panel {
            background: var(--ui-bg);
            border-top: 3px solid var(--ui-border);
            padding: 15px;
            height: 140px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        #selection-info {
            width: 220px;
            border-right: 1px solid var(--ui-border);
            padding-right: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        #selection-name { font-size: 1.3rem; color: var(--accent); font-weight: bold; margin-bottom: 5px; }
        #selection-stats { font-size: 0.9rem; color: #ccc; }
        #queue-info { font-size: 0.8rem; color: #aaa; margin-top: 5px; }

        #actions-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            flex-grow: 1;
        }

        .action-btn {
            background: linear-gradient(to bottom, #4a4a5e, #2a2a3e);
            border: 1px solid var(--ui-border);
            color: var(--ui-text);
            padding: 8px;
            cursor: pointer;
            transition: all 0.1s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            position: relative;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.2);
            border-radius: 4px;
        }

        .action-btn:hover { background: #505070; border-color: var(--accent); transform: translateY(-1px); }
        .action-btn:active { transform: translateY(1px); }
        .action-btn:disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(1); }
        
        .cost-tooltip { font-size: 0.7rem; color: #aaa; margin-top: 2px; }
        .hotkey { position: absolute; top: 2px; right: 4px; font-size: 0.7rem; color: #ffd700; font-weight: bold; }

        /* Selection Box */
        #selection-box {
            position: absolute;
            border: 1px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            display: none;
            z-index: 5;
        }

        /* Health Bar Overlay */
        #health-bar-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; overflow: hidden; z-index: 4;
        }

        .hp-bar {
            position: absolute;
            width: 40px; height: 5px; background: #000;
            transform: translate(-50%, -50%);
            display: none; border: 1px solid rgba(0,0,0,0.5);
            border-radius: 2px;
        }
        .hp-fill {
            height: 100%; background: #00ff00; width: 100%;
            transition: width 0.2s, background-color 0.2s;
        }

        /* Notifications */
        #notification-area {
            position: absolute; top: 80px; left: 50%;
            transform: translateX(-50%);
            display: flex; flex-direction: column; gap: 5px; align-items: center;
        }
        .toast {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 14px;
            border-radius: 4px;
            font-size: 0.9rem;
            border-left: 4px solid var(--accent);
            animation: fadeOut 3s forwards;
        }
        @keyframes fadeOut { 0% { opacity: 1; transform: translateY(0); } 80% { opacity: 1; } 100% { opacity: 0; transform: translateY(-20px); } }

        /* Start Screen */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 100;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: var(--ui-text);
            pointer-events: auto;
        }
        h1 { color: var(--accent); font-size: 3rem; margin-bottom: 10px; letter-spacing: 5px; text-transform: uppercase; }
        .btn-large {
            padding: 15px 40px; font-size: 1.5rem; background: var(--accent); color: #000; border: none; cursor: pointer; font-weight: bold;
            border-radius: 4px; transition: transform 0.2s;
        }
        .btn-large:hover { transform: scale(1.05); background: #fff; }
        .instructions { margin-bottom: 30px; text-align: center; line-height: 1.6; max-width: 600px; color: #ccc; }
        .key { background: #444; padding: 2px 6px; border-radius: 4px; border-bottom: 2px solid #222; font-family: monospace; color: #fff; }

    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="game-container"></div>
    <div id="selection-box"></div>
    <div id="health-bar-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div id="resource-bar">
            <div class="res-item"><span class="res-icon">ü™µ</span> <span id="res-wood">200</span></div>
            <div class="res-item"><span class="res-icon">üåæ</span> <span id="res-food">200</span></div>
            <div class="res-item"><span class="res-icon">ü™ô</span> <span id="res-gold">100</span></div>
            <div class="res-item"><span class="res-icon">üõ¢Ô∏è</span> <span id="res-oil">0</span></div>
            <div class="res-item" style="margin-left:auto; color: #aaa; font-size: 0.9rem;">
                Pop: <span id="res-pop">0</span>/<span id="res-max-pop">10</span>
            </div>
        </div>

        <div id="notification-area"></div>

        <div id="control-panel">
            <div id="selection-info">
                <div id="selection-name">Nothing Selected</div>
                <div id="selection-stats">-</div>
                <div id="queue-info"></div>
            </div>
            <div id="actions-grid"></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>Empire Prototype V5</h1>
        <div class="instructions">
            <p><strong>Updates:</strong> Production Queues, Arrow Keys Panning, Timed Construction.</p>
            <p><strong>Controls:</strong></p>
            <p>Left Click: Select | Arrow Keys: Pan Camera | Right Click: Command</p>
        </div>
        <button class="btn-large" onclick="window.startGame()">Start Game</button>
    </div>

    <!-- Logic -->
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIG ---
        const CONFIG = {
            COLORS: {
                PLAYER: 0x4488ff,
                PLAYER_BUILDING: 0x3366cc,
                ENEMY: 0xff4444,
                ENEMY_BUILDING: 0xcc3333,
                GHOST: 0x00ff00,
                GROUND: 0x2e5a2e,
                FOUNDATION: 0x555555
            },
            COSTS: {
                VILLAGER: { food: 50 },
                SOLDIER: { food: 60, gold: 20 },
                HOUSE: { wood: 30 },
                BARRACKS: { wood: 150 }
            },
            AI_THINK_INTERVAL: 2000,
            AI_APM_LIMIT: 1000,
            BUILD_TIMES: {
                VILLAGER: 3,
                SOLDIER: 4,
                HOUSE: 5,
                BARRACKS: 8
            }
        };

        // --- STATE ---
        const state = {
            playerResources: { wood: 200, food: 200, gold: 100, oil: 0 },
            enemyResources: { wood: 200, food: 200, gold: 100, oil: 0 },
            playerPop: 0, playerMaxPop: 5,
            enemyPop: 0, enemyMaxPop: 5,
            
            selection: [],
            entities: [],
            buildingMode: null,
            ghostMesh: null,
            isPlaying: false,
            
            aiMemory: {
                buildingHouse: false,
                buildingBarracks: false,
                gatherRate: { wood: 0, food: 0, gold: 0 },
                lastActionTime: 0
            },

            keysPressed: {} // For Arrow Key Panning
        };

        // --- THREE.JS SETUP ---
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 100, 350);

        const aspect = window.innerWidth / window.innerHeight;
        const d = 100;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(100, 100, 100);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableRotate = true;
        controls.enableZoom = true;
        controls.enablePan = false; // Disable default pan to use our custom logic
        controls.minZoom = 0.5;
        controls.maxZoom = 2;
        controls.mouseButtons = { LEFT: null, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Ground
        const groundGeo = new THREE.PlaneGeometry(400, 400);
        const groundMat = new THREE.MeshStandardMaterial({ color: CONFIG.COLORS.GROUND });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.name = "Ground";
        scene.add(ground);
        
        const grid = new THREE.GridHelper(400, 40, 0x000000, 0x000000);
        grid.material.opacity = 0.1;
        grid.material.transparent = true;
        scene.add(grid);
        

        /**
         * ASSET GENERATION LOGIC
         * 
         * This section contains the pure Three.js logic to build models.
         * The architecture uses functions that return a THREE.Group (which behaves like a composite Mesh).
         */

        const AssetFactory = (function() {
            // Reusable Materials
            const mats = {
                stone: new THREE.MeshLambertMaterial({ color: 0x888888 }),
                stoneDark: new THREE.MeshLambertMaterial({ color: 0x555555 }),
                wood: new THREE.MeshLambertMaterial({ color: 0x8B4513 }),
                woodDark: new THREE.MeshLambertMaterial({ color: 0x5C4033 }),
                crop: new THREE.MeshLambertMaterial({ color: 0x55aa55 }),
                ground: new THREE.MeshLambertMaterial({ color: 0x5d4037 }),
                plaster: new THREE.MeshLambertMaterial({ color: 0xf0f0e0 }), // Asian walls
                roofDefault: new THREE.MeshLambertMaterial({ color: 0xcccccc })
            };

            // Helper to create theme material
            const getThemeMat = (color) => new THREE.MeshLambertMaterial({ color: color });

            // Helper: Create Box
            function box(w, h, d, mat, x, y, z) {
                const geo = new THREE.BoxGeometry(w, h, d);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            // Helper: Create Cylinder/Pillar
            function pillar(rt, rb, h, mat, x, y, z) {
                const geo = new THREE.CylinderGeometry(rt, rb, h, 8);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            // Helper: Create Roof (Pyramid style)
            function roof(w, d, h, mat, x, y, z) {
                // Using Cone with 4 radial segments creates a pyramid
                const geo = new THREE.ConeGeometry(Math.max(w,d) * 0.75, h, 4);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                mesh.rotation.y = Math.PI / 4; // Align flat sides to axes
                mesh.castShadow = true;
                return mesh;
            }

            function overwriteMatPreset(mats, overrideMat) {
                if (!overrideMat) return mats;
                return  {
                stone: overrideMat,
                stoneDark: overrideMat,
                wood: overrideMat,
                woodDark: overrideMat,
                crop: overrideMat,
                ground: overrideMat,
                plaster: overrideMat, // Asian walls
                roofDefault: overrideMat
                };
            }

            // 1. TOWN CENTER
            function createTownCenter(civ, themeColor, overrideMat) {
                const group = new THREE.Group();
                const themeMat = overrideMat || getThemeMat(themeColor);
                const mmats = overwriteMatPreset(mats, overrideMat);

                if (civ === 'kingdom') {
                    // Base
                    group.add(box(8, 1, 8, mmats.stoneDark, 0, 0.5, 0));
                    // Main Hall
                    group.add(box(7, 5, 6, mmats.stone, 0, 3.5, 0));
                    // Door
                    group.add(box(2, 3, 0.2, mmats.woodDark, 0, 1.5, 3));
                    // Roof
                    const r = roof(8, 8, 4, themeMat, 0, 7, 0);
                    group.add(r);
                    // Tower
                    group.add(box(2, 7, 2, mmats.stone, 2.5, 4.5, 0));
                    const rt = roof(2.5, 2.5, 2, themeMat, 2.5, 8.5, 0);
                    group.add(rt);
                    // Flag
                    group.add(pillar(0.1, 0.1, 4, mmats.wood, 2.5, 10.5, 0));
                    group.add(box(1.5, 1, 0.1, themeMat, 3.2, 10.5, 0));

                } else if (civ === 'empire') {
                    // Raised Platform
                    group.add(box(9, 0.5, 9, mmats.stoneDark, 0, 0.25, 0));
                    // Main Body
                    group.add(box(7, 4, 6, mmats.plaster, 0, 2.5, 0));
                    // Pillars
                    const pos = [-2.5, 2.5];
                    pos.forEach(x => {
                        pos.forEach(z => {
                            group.add(pillar(0.3, 0.3, 4, mmats.woodDark, x, 2.5, z * 1.5));
                        });
                    });
                    // Tiered Roof 1
                    const r1 = roof(8, 7, 2, themeMat, 0, 5.5, 0);
                    group.add(r1);
                    // Top Tier
                    group.add(box(3, 1.5, 3, mmats.plaster, 0, 6.75, 0));
                    const r2 = roof(4, 4, 2, themeMat, 0, 8.5, 0);
                    group.add(r2);
                }

                return group;
            }

            // 2. HOUSE
            function createHouse(civ, themeColor, overrideMat) {
                const group = new THREE.Group();
                const themeMat = overrideMat || getThemeMat(themeColor);
                const mmats = overwriteMatPreset(mats, overrideMat);

                if (civ === 'kingdom') {
                    group.add(box(4, 3, 4, mmats.stone, 0, 1.5, 0));
                    group.add(box(1.2, 2, 0.2, mmats.woodDark, 0, 1, 2.01)); // Door
                    group.add(roof(5, 5, 2.5, themeMat, 0, 3.75, 0));
                } else if (civ === 'empire') {
                    group.add(box(4, 2.5, 4, mmats.plaster, 0, 1.25, 0));
                    group.add(roof(5, 5, 2, themeMat, 0, 2.75, 0)); // Curved flaring simulated by wide cone base
                }
                return group;
            }

            // 3. BARRACKS
            function createBarracks(civ, themeColor, overrideMat) {
                const group = new THREE.Group();
                const themeMat = overrideMat || getThemeMat(themeColor);
                const mmats = overwriteMatPreset(mats, overrideMat);

                if (civ === 'kingdom') {
                    group.add(box(8, 3.5, 5, mmats.stone, 0, 1.75, 0));
                    // Gate
                    group.add(box(3, 2.5, 0.5, mmats.woodDark, 0, 1.25, 2.5));
                    group.add(roof(9, 6, 3, themeMat, 0, 4.5, 0));
                    // Flags on sides
                    [-3.5, 3.5].forEach(x => {
                        group.add(pillar(0.1, 0.1, 2.5, mmats.wood, x, 4, 0));
                        group.add(box(1.2, 0.8, 0.1, themeMat, x + 0.6, 5.2, 0));
                    });

                } else if (civ === 'empire') {
                    group.add(box(8, 3, 5, mmats.plaster, 0, 1.5, 0));
                    // Wide roof
                    const r = roof(9, 6, 2, themeMat, 0, 3.5, 0);
                    group.add(r);
                    // Training posts in front
                    for(let i=-2; i<=2; i+=2) {
                        group.add(pillar(0.1, 0.1, 4, mmats.woodDark, i, 2, 3));
                    }
                }
                return group;
            }

            // 4. MARKET
            function createMarket(civ, themeColor) {
                const group = new THREE.Group();
                const themeMat = getThemeMat(themeColor);

                if (civ === 'kingdom') {
                    // Stalls
                    group.add(box(3, 2.5, 3, mats.wood, -2, 1.25, 0));
                    group.add(box(3, 2.5, 3, mats.wood, 2, 1.25, 0));
                    // Awning
                    group.add(box(7, 0.2, 4, themeMat, 0, 3, 0)); // Theme color here as stripe
                    group.add(box(7, 0.2, 4, mats.wood, 0, 2.8, 0));
                    // Roof
                    group.add(roof(7.5, 4.5, 2, themeMat, 0, 4, 0));
                } else if (civ === 'empire') {
                    // Open front
                    group.add(box(6, 3, 4, mats.plaster, 0, 1.5, -1));
                    // Roof
                    group.add(roof(7, 5, 2.5, themeMat, 0, 4, 0));
                    // Goods table
                    group.add(box(4, 0.5, 2, mats.woodDark, 0, 0.25, 2));
                }
                return group;
            }

            // 5. CAMP (Universal)
            function createCamp(civ, themeColor) {
                // Camp ignores civ, uses 'themeColor' for the canvas roof
                const group = new THREE.Group();
                const themeMat = getThemeMat(themeColor);

                // Logs
                const logH = 2.5;
                const logGeo = new THREE.CylinderGeometry(0.2, 0.2, logH, 6);
                [[-1.5,1.5], [0,1.5], [1.5,1.5], [-1.5,-1.5], [1.5,-1.5]].forEach(pos => {
                    const l = new THREE.Mesh(logGeo, mats.woodDark);
                    l.position.set(pos[0], logH/2, pos[1]);
                    l.castShadow = true;
                    group.add(l);
                });

                // Tarp Roof (Prism)
                const roofGeo = new THREE.CylinderGeometry(0, 2.5, 2, 3);
                const roofMesh = new THREE.Mesh(roofGeo, themeMat);
                roofMesh.position.set(0, logH + 1, 0);
                roofMesh.rotation.y = Math.PI / 2;
                roofMesh.rotation.x = Math.PI / 2; // Flat orientation
                // Actually use a prism shape rotated
                // Reset rotation manual
                roofMesh.rotation.set(0, 0, 0);
                roofMesh.rotation.y = -Math.PI/2;
                roofMesh.position.set(0, 2.5, 0);
                
                // Wait, easier to just use Cone(3)
                const tentGeo = new THREE.ConeGeometry(2.2, 2, 3);
                const tent = new THREE.Mesh(tentGeo, themeMat);
                tent.position.set(0, 2.5, 0);
                tent.rotation.y = Math.PI / 2;
                tent.castShadow = true;
                group.add(tent);

                // Drop point (Crate)
                group.add(box(1, 1, 1, mats.wood, 0, 0.5, 1));

                return group;
            }

            // 6. FARM (Universal)
            function createFarm(civ, themeColor) {
                const group = new THREE.Group();
                
                // Field
                group.add(box(5, 0.2, 5, mats.crop, 0, 0.1, 0));
                
                // Crops (simple instances)
                const cropGeo = new THREE.BoxGeometry(0.2, 0.4, 0.2);
                for(let x=-2; x<=2; x+=1) {
                    for(let z=-2; z<=2; z+=1) {
                        if(Math.random() > 0.3) {
                            const c = new THREE.Mesh(cropGeo, mats.crop);
                            c.position.set(x, 0.4, z);
                            group.add(c);
                        }
                    }
                }

                // Small Shed (Neutral style)
                group.add(box(1.5, 1.5, 1.5, mats.woodDark, 2, 0.75, 2));
                group.add(roof(2, 2, 1, mats.woodDark, 2, 1.75, 2));

                return group;
            }

            // 7. TOWER
            function createTower(civ, themeColor) {
                const group = new THREE.Group();
                const themeMat = getThemeMat(themeColor);

                if (civ === 'kingdom') {
                    // Stone cylinder
                    group.add(pillar(1.5, 1.5, 6, mats.stone, 0, 3, 0));
                    // Crenellations (Top blocks)
                    for(let i=0; i<4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const c = box(0.8, 0.5, 0.8, mats.stone, Math.cos(angle)*1.5, 6.25, Math.sin(angle)*1.5);
                        c.lookAt(0,6.25,0);
                        group.add(c);
                    }
                    // Roof
                    group.add(roof(3, 3, 2, themeMat, 0, 7.5, 0));

                } else if (civ === 'empire') {
                    // Stone base
                    group.add(pillar(1.4, 1.4, 5, mats.stoneDark, 0, 2.5, 0));
                    // Wood top
                    group.add(pillar(1.4, 1.4, 2, mats.plaster, 0, 5.5, 0));
                    // Roof
                    const r = roof(3.5, 3.5, 2.5, themeMat, 0, 7.5, 0);
                    group.add(r);
                }

                return group;
            }

            // Public API
            return {
                create: function(type, civ, color, overrideMat) {
                    // Adjust Civ for neutral buildings
                    let effectiveCiv = civ;
                    if (type === 'camp' || type === 'farm') effectiveCiv = 'neutral';

                    switch(type) {
                        case 'TownCenter': return createTownCenter(effectiveCiv, color, overrideMat);
                        case 'House': return createHouse(effectiveCiv, color, overrideMat);
                        case 'Barracks': return createBarracks(effectiveCiv, color, overrideMat);
                        case 'market': return createMarket(effectiveCiv, color, overrideMat);
                        case 'camp': return createCamp(effectiveCiv, color, overrideMat);
                        case 'farm': return createFarm(effectiveCiv, color, overrideMat);
                        case 'tower': return createTower(effectiveCiv, color, overrideMat);
                        default: return new THREE.Group();
                    }
                }
            };
        })();


        // --- ENTITY SYSTEM ---
        class Entity {
            constructor(type, owner, position) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.type = type;
                this.owner = owner;
                this.position = position.clone();
                this.mesh = null;
                this.hp = 100;
                this.maxHp = 100;
                this.dead = false;
                
                this.hpBarEl = document.createElement('div');
                this.hpBarEl.className = 'hp-bar';
                this.hpBarEl.innerHTML = '<div class="hp-fill"></div>';
                document.getElementById('health-bar-container').appendChild(this.hpBarEl);
            }

            remove() {
                this.dead = true;
                if (this.mesh) scene.remove(this.mesh);
                if (this.hpBarEl) this.hpBarEl.remove();
                if (this.selectionRing) scene.remove(this.selectionRing);
            }

            takeDamage(amount) {
                this.hp -= amount;
                this.showHealthBar(true);
                this.updateHealthBarUI();
                if (this.hp <= 0) this.remove();
            }

            showHealthBar(show) {
                this.hpBarEl.style.display = show ? 'block' : 'none';
            }

            updateHealthBarUI() {
                const fill = this.hpBarEl.querySelector('.hp-fill');
                const pct = Math.max(0, this.hp / this.maxHp);
                fill.style.width = (pct * 100) + '%';
                fill.style.backgroundColor = pct > 0.5 ? '#00ff00' : (pct > 0.25 ? '#ffff00' : '#ff0000');
            }
        }

        class Unit extends Entity {
            constructor(type, owner, position) {
                super(type, owner, position);
                this.speed = type === 'Villager' ? 15 : 22;
                this.state = 'IDLE'; // IDLE, MOVE, GATHER, RETURN, ATTACK, CONSTRUCT
                this.targetPos = null;
                this.targetEntity = null;
                
                // Construction specific
                this.constructType = null;
                this.constructTimer = 0;

                this.inventory = 0;
                this.maxInventory = 10;
                this.gatherType = null;
                
                this.range = type === 'Soldier' ? 1.5 : 3;
                this.attackDamage = type === 'Soldier' ? 12 : 5;
                this.attackCooldown = 0;
                this.attackTimerMax = 1.0;

                const color = owner === 'player' ? CONFIG.COLORS.PLAYER : CONFIG.COLORS.ENEMY;
                const height = type === 'Soldier' ? 3 : 2.2;
                const geometry = new THREE.CapsuleGeometry(0.8, height - 1.6, 4, 8);
                const material = new THREE.MeshStandardMaterial({ color: color });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.mesh.position.y = height / 2;
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.userData = { entity: this };
                scene.add(this.mesh);

                const ringGeo = new THREE.RingGeometry(1.2, 1.4, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                this.selectionRing = new THREE.Mesh(ringGeo, ringMat);
                this.selectionRing.rotation.x = -Math.PI / 2;
                this.selectionRing.position.copy(position);
                this.selectionRing.position.y = 0.1;
                this.selectionRing.visible = false;
                scene.add(this.selectionRing);
            }

            update(dt) {
                if (this.dead) return;

                // Update HP Bar Position
                const screenPos = this.position.clone().project(camera);
                const x = (screenPos.x + 1) / 2 * window.innerWidth;
                const y = -(screenPos.y - 1) / 2 * window.innerHeight;
                this.hpBarEl.style.left = x + 'px';
                this.hpBarEl.style.top = (y - 20) + 'px';

                this.attackCooldown -= dt;

                if (this.state === 'MOVE' && this.targetPos) {
                    this.moveTo(this.targetPos, dt);
                    if (this.position.distanceTo(this.targetPos) < 1) this.state = 'IDLE';
                }
                else if (this.state === 'GATHER' && this.targetEntity) {
                    if (this.targetEntity.dead) { this.state = 'IDLE'; return; }
                    const dist = this.position.distanceTo(this.targetEntity.position);
                    if (dist > 3) {
                        this.moveTo(this.targetEntity.position, dt);
                    } else {
                        if (this.inventory < this.maxInventory) {
                            this.inventory += dt * 2;
                            const s = 1 + Math.sin(Date.now()*0.015)*0.1;
                            this.mesh.scale.set(s,s,s);
                        } else {
                            this.state = 'RETURN';
                            this.targetEntity = findNearestBuilding(this.owner, 'TownCenter');
                            this.mesh.scale.setScalar(1);
                        }
                    }
                }
                else if (this.state === 'RETURN' && this.targetEntity) {
                    const dist = this.position.distanceTo(this.targetEntity.position);
                    if (dist > 4) {
                        this.moveTo(this.targetEntity.position, dt);
                    } else {
                        const amount = Math.floor(this.inventory);
                        if (amount > 0) {
                            addResource(this.owner, this.gatherType, amount);
                            if (this.owner === 'player') showFloatText(`+${amount}`, this.position);
                        }
                        this.inventory = 0;
                        const lastResource = findNearestResource(this.position, this.gatherType);
                        if (lastResource) {
                            this.targetEntity = lastResource;
                            this.state = 'GATHER';
                        } else { this.state = 'IDLE'; }
                    }
                }
                else if (this.state === 'ATTACK' && this.targetEntity) {
                    if (this.targetEntity.dead) { this.state = 'IDLE'; return; }
                    const dist = this.position.distanceTo(this.targetEntity.position);
                    if (dist > this.range) {
                        this.moveTo(this.targetEntity.position, dt);
                    } else {
                        if (this.attackCooldown <= 0) {
                            this.targetEntity.takeDamage(this.attackDamage);
                            this.attackCooldown = this.attackTimerMax;
                        }
                    }
                }
                else if (this.state === 'CONSTRUCT' && this.targetPos) {
                    const dist = this.position.distanceTo(this.targetPos);
                    if (dist > 2) {
                        this.moveTo(this.targetPos, dt);
                    } else {
                        // Building Work
                        this.constructTimer += dt;
                        
                        // Hammer animation
                        this.mesh.rotation.y = Math.sin(Date.now() * 0.015) * 0.5;
                        
                        if (this.constructTimer >= CONFIG.BUILD_TIMES[this.constructType.toUpperCase()]) {
                            // Place the actual building
                            createBuilding(this.constructType, this.owner, this.targetPos);
                            if (this.temporaryFoundationMesh) { scene.remove(this.temporaryFoundationMesh); }
                            //console.log(this);
                            //console.log(state);
                            
                            // If AI built it, reset memory
                            if (this.owner === 'enemy') {
                                if (this.constructType === 'House') state.aiMemory.buildingHouse = false;
                                if (this.constructType === 'Barracks') state.aiMemory.buildingBarracks = false;
                            }
                            
                            this.state = 'IDLE';
                            this.constructType = null;
                            this.constructTimer = 0;
                            this.mesh.rotation.y = 0;
                        }
                    }
                }

                // Separation
                const neighbors = state.entities.filter(e => e !== this && e instanceof Unit && !e.dead && e.position.distanceTo(this.position) < 2.5);
                if (neighbors.length > 0) {
                    const sep = new THREE.Vector3();
                    neighbors.forEach(n => sep.add(new THREE.Vector3().subVectors(this.position, n.position).normalize()));
                    this.position.add(sep.multiplyScalar(dt * 5));
                    this.syncMesh();
                }
            }

            moveTo(target, dt) {
                const dir = new THREE.Vector3().subVectors(target, this.position).normalize();
                dir.y = 0;
                this.position.add(dir.multiplyScalar(this.speed * dt));
                this.syncMesh();
                this.mesh.lookAt(target);
            }
            
            syncMesh() {
                this.mesh.position.copy(this.position);
                this.mesh.position.y = (this.type === 'Soldier' ? 3 : 2.2) / 2;
                this.selectionRing.position.copy(this.position);
                this.selectionRing.position.y = 0.1;
            }

            setSelected(bool) {
                this.selectionRing.visible = bool;
                this.showHealthBar(bool);
            }
        }

        class Building extends Entity {
            constructor(type, owner, position) {
                super(type, owner, position);
                
                // Production Queue System
                this.productionQueue = [];
                this.productionTimer = 0;
                this.isProducing = false;

                /*
                let w, h, d;
                if (type === 'TownCenter') { w=8; h=8; d=8; }
                else if (type === 'House') { w=5; h=5; d=4; }
                else if (type === 'Barracks') { w=8; h=5; d=6; }

                const color = owner === 'player' ? CONFIG.COLORS.PLAYER_BUILDING : CONFIG.COLORS.ENEMY_BUILDING;
                const geometry = new THREE.BoxGeometry(w, h, d);
                const material = new THREE.MeshStandardMaterial({ color: color });
                this.mesh = new THREE.Mesh(geometry, material);
                */
                //TODO
                const faction = owner === 'player' ? "kingdom" : "empire";
                const color = owner === 'player' ? CONFIG.COLORS.PLAYER_BUILDING : CONFIG.COLORS.ENEMY_BUILDING;
                this.mesh = AssetFactory.create(type, faction, color);
                this.mesh.position.copy(position);
                //this.mesh.position.y = h/2;
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.userData = { entity: this };
                scene.add(this.mesh);
                
                this.uiUpdateTimer = Date.now();
            }

            update(dt) {
                // UI Position
                const screenPos = this.position.clone().project(camera);
                const x = (screenPos.x + 1) / 2 * window.innerWidth;
                const y = -(screenPos.y - 1) / 2 * window.innerHeight;
                this.hpBarEl.style.left = x + 'px';
                this.hpBarEl.style.top = (y - 40) + 'px';

                // Production Logic
                if (this.productionQueue.length > 0) {
                    this.isProducing = true;
                    this.productionTimer += dt;

                    // Get current item
                    const currentItem = this.productionQueue[0];
                    const timeNeeded = CONFIG.BUILD_TIMES[currentItem.type] || 3;

                    // Visual cue for working (Pulse scale slightly?)
                    if (this.isProducing) {
                        const s = 1 + Math.sin(Date.now()*0.005) * 0.02;
                        this.mesh.scale.set(s,s,s);
                    }

                    if (this.productionTimer >= timeNeeded) {
                        // Spawn Unit
                        const spawnPos = this.position.clone().add(new THREE.Vector3(0, 0, 8));
                        // Check pop cap again at finish just in case
                        const pop = this.owner === 'player' ? state.playerPop : state.enemyPop;
                        const max = this.owner === 'player' ? state.playerMaxPop : state.enemyMaxPop;
                        
                        if (pop < max) {
                            const spawnedUnit = createUnit(currentItem.type, this.owner, spawnPos);
                            if (this.gatherPointPos) {
                                spawnedUnit.state = 'MOVE'; spawnedUnit.targetPos = this.gatherPointPos;
                            }
                        } else {
                            // Refund logic could go here, for now just consume it silently (rare edge case if pop filled during queue)
                            if (this.owner === 'player') notify("Queue finished but pop full!");
                        }

                        // Remove from queue
                        this.productionQueue.shift();
                        this.productionTimer = 0;

                        if (this.productionQueue.length === 0) {
                            this.isProducing = false;
                            this.mesh.scale.setScalar(1);
                        }
                        // Still needed because timer update is async and we may miss the cycle
                        // If selected by player, update UI
                        if (state.selection.includes(this)) updateUISelection();
                    }
                    const now = Date.now();
                    if (now - this.uiUpdateTimer > 500) {
                        // If selected by player, update UI
                        if (state.selection.includes(this)) updateUISelection();
                        this.uiUpdateTimer = now;
                    }
                } else {
                     this.mesh.scale.setScalar(1);
                }
            }

            addToQueue(type, cost, owner) {
                this.productionQueue.push({ type, cost, owner });
            }
            
            setSelected(bool) {
                this.showHealthBar(bool);
            }
        }

        class Resource extends Entity {
            constructor(type, position) {
                super(type, 'gaia', position);
                let color, geo;
                if (type === 'Tree') {
                    color = 0x2e8b57; geo = new THREE.ConeGeometry(1.5, 6, 8); this.meshType = 'wood';
                } else if (type === 'GoldMine') {
                    color = 0xffd700; geo = new THREE.DodecahedronGeometry(2.5); this.meshType = 'gold';
                } else if (type === 'BerryBush') {
                    color = 0xff6347; geo = new THREE.SphereGeometry(1.5, 8, 8); this.meshType = 'food';
                } else if (type === 'OilSeep') {
                    color = 0x111111; geo = new THREE.CylinderGeometry(3, 3, 0.5, 16); this.meshType = 'oil';
                }
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(position);
                this.mesh.position.y = type === 'Tree' ? 3 : (type === 'OilSeep' ? 0.25 : 1.5);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.userData = { entity: this };
                scene.add(this.mesh);
            }
            
            update(dt) {}
        }

        // --- GAMEPLAY LOGIC ---

        function initGame() {
            // Player Setup
            createBuilding('TownCenter', 'player', new THREE.Vector3(0, 0, 20));
            createUnit('Villager', 'player', new THREE.Vector3(5, 0, 25));
            createUnit('Villager', 'player', new THREE.Vector3(-5, 0, 25));
            createUnit('Soldier', 'player', new THREE.Vector3(0, 0, 30));

            // Enemy Setup
            const enemyBase = new THREE.Vector3(60, 0, 60);
            createBuilding('TownCenter', 'enemy', enemyBase);
            createUnit('Villager', 'enemy', enemyBase.clone().add(new THREE.Vector3(5, 0, 5)));
            createUnit('Villager', 'enemy', enemyBase.clone().add(new THREE.Vector3(-5, 0, 5)));
            createUnit('Soldier', 'enemy', enemyBase.clone().add(new THREE.Vector3(0, 0, -8)));

            // Resources
            for(let i=0; i<20; i++) {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                if (Math.abs(x) < 30 && Math.abs(z) < 30) continue;
                createResource('Tree', new THREE.Vector3(x, 0, z));
            }
            createResource('GoldMine', new THREE.Vector3(30, 0, -30));
            createResource('GoldMine', new THREE.Vector3(90, 0, 90));
            createResource('BerryBush', new THREE.Vector3(-30, 0, -30));
            createResource('BerryBush', new THREE.Vector3(50, 0, 50));
            createResource('OilSeep', new THREE.Vector3(-50, 0, 50));
            createResource('OilSeep', new THREE.Vector3(80, 0, 40));

            state.isPlaying = true;
            animate();
            setInterval(aiTick, CONFIG.AI_THINK_INTERVAL);
        }

        function addResource(owner, type, amount) {
            if (!type || type === 'oil') return; 
            const res = owner === 'player' ? state.playerResources : state.enemyResources;
            if (res[type] !== undefined) {
                res[type] += amount;
                if (owner === 'player') updateUI();
            }
        }

        function createUnit(type, owner, pos) {
            const pop = owner === 'player' ? state.playerPop : state.enemyPop;
            const max = owner === 'player' ? state.playerMaxPop : state.enemyMaxPop;
            
            if (pop >= max) { 
                if (owner === 'player') notify("Population Limit Reached!"); 
                return; 
            }
            
            const u = new Unit(type, owner, pos);
            state.entities.push(u);
            if (owner === 'player') state.playerPop++;
            else state.enemyPop++;
            updateUI();

            return u;
        }

        function createBuilding(type, owner, pos) {
            console.log("Create building succeed? Type: " + type);
            const b = new Building(type, owner, pos);
            state.entities.push(b);
            if (type === 'House') {
                if (owner === 'player') state.playerMaxPop += 5;
                else state.enemyMaxPop += 5;
                updateUI();
            }
        }

        function createResource(type, pos) {
            state.entities.push(new Resource(type, pos));
        }

        function findNearestBuilding(owner, type) {
            let nearest = null; let minDist = Infinity;
            state.entities.forEach(e => {
                if (e.owner === owner && e.type === type && !e.dead) {
                    const d = e.position.distanceTo(this ? this.position : new THREE.Vector3(0,0,0));
                    if (d < minDist) { minDist = d; nearest = e; }
                }
            });
            return nearest;
        }

        function findNearestResource(pos, type) {
            let nearest = null; let minDist = Infinity;
            state.entities.forEach(e => {
                if ((type ? e.meshType === type : true) && !e.dead) {
                    const d = e.position.distanceTo(pos);
                    if (d < minDist) { minDist = d; nearest = e; }
                }
            });
            return nearest;
        }

        // --- TRAINING & QUEUE SYSTEM ---

        function trainUnit(building, unitType, cost, owner) {
            // Resource Check
            const res = owner === 'player' ? state.playerResources : state.enemyResources;
            if (res.food < (cost.food||0) || res.gold < (cost.gold||0)) {
                if (owner === 'player') notify("Insufficient Resources!");
                return false;
            }

            // Deduct Immediately
            res.food -= (cost.food||0);
            res.gold -= (cost.gold||0);
            if (owner === 'player') updateUI();

            // Add to Queue
            building.addToQueue(unitType, cost, owner);
            return true;
        }

        // --- AI SYSTEM ---

        const AI_RULES = [
            {
                name: "Build House",
                condition: () => {
                    const pop = state.enemyPop;
                    const max = state.enemyMaxPop;
                    // Build house if we are close to cap (within 2), aren't already building one, and have wood
                    return (pop + 2 >= max) && !state.aiMemory.buildingHouse && state.enemyResources.wood >= 30;
                },
                action: () => {
                    const villager = getEnemyVillager(true);
                    const tc = getEnemyTownCenter();
                    if (villager && tc) {
                        const spot = tc.position.clone().add(new THREE.Vector3((Math.random()-0.5)*15 + 10, 0, (Math.random()-0.5)*15 + 10));
                        
                        // Deduct cost for construction
                        state.enemyResources.wood -= 30;
                        
                        villager.state = 'CONSTRUCT';
                        villager.targetPos = spot;
                        villager.constructType = 'House';
                        villager.constructTimer = 0;
                        
                        state.aiMemory.buildingHouse = true;
                    }
                }
            },
            {
                name: "Build Barracks",
                condition: () => {
                    const barracks = state.entities.filter(e => e.owner === 'enemy' && e.type === 'Barracks').length;
                    return barracks === 0 && !state.aiMemory.buildingBarracks && state.enemyResources.wood >= 150;
                },
                action: () => {
                    const villager = getEnemyVillager(true);
                    const tc = getEnemyTownCenter();
                    if (villager && tc) {
                        const spot = tc.position.clone().add(new THREE.Vector3(10, 0, 10));
                        
                        state.enemyResources.wood -= 150;

                        villager.state = 'CONSTRUCT';
                        villager.targetPos = spot;
                        villager.constructType = 'Barracks';
                        villager.constructTimer = 0;
                        
                        state.aiMemory.buildingBarracks = true;
                    }
                }
            },
            {
                name: "Train Villager",
                condition: () => {
                    const tc = getEnemyTownCenter();
                    const villagers = state.entities.filter(e => e.owner === 'enemy' && e.type === 'Villager' && !e.dead).length;
                    const soldiers = state.entities.filter(e => e.owner === 'enemy' && e.type === 'Soldier' && !e.dead).length;
                    // Keep queue small so AI doesn't drain all food instantly
                    return tc && tc.productionQueue.length < 2 && state.enemyResources.food >= 50 && soldiers >= villagers / 3;
                },
                action: () => {
                    const tc = getEnemyTownCenter();
                    if (tc) trainUnit(tc, 'Villager', CONFIG.COSTS.VILLAGER, 'enemy');
                }
            },
            {
                name: "Assign Idle Villagers",
                condition: () => {
                    const v = getEnemyVillager(true); 
                    return v !== undefined; //array.find return undefined if not found, not null
                },
                action: () => {
                    const v = getEnemyVillager(true);
                    if (!v) return;
                    
                    let allResType = [{ type: 'wood', rate: 0.5 * state.aiMemory.gatherRate.wood }, { type: 'food', rate: 0.33 * state.aiMemory.gatherRate.food }, { type: 'gold', rate: 1 * state.aiMemory.gatherRate.gold }];
                    allResType.sort((a, b) => { return (a.rate - b.rate); }); //from current rate min, ascending
                    console.log(allResType);

                    let resType = 'food';
                    let target = null;
                    for (let res of allResType) {
                        target = findNearestResource(v.position, res.type);
                        if (target) {
                            resType = res.type;
                            break;
                        }
                    }
                    
                    if (target) {
                        v.state = 'GATHER';
                        v.targetEntity = target;
                        v.gatherType = resType;
                        
                        state.aiMemory.gatherRate[resType] += 1;
                    }
                }
            },
            {
                name: "Train Soldier",
                condition: () => {
                    const barracks = state.entities.find(e => e.owner === 'enemy' && e.type === 'Barracks');
                    return barracks && barracks.productionQueue.length < 2 && 
                           state.enemyResources.food >= 60 && 
                           state.enemyResources.gold >= 20;
                },
                action: () => {
                    const barracks = state.entities.find(e => e.owner === 'enemy' && e.type === 'Barracks');
                    if (barracks) trainUnit(barracks, 'Soldier', CONFIG.COSTS.SOLDIER, 'enemy');
                }
            },
            {
                name: "Attack",
                condition: () => {
                    const soldiers = state.entities.filter(e => e.owner === 'enemy' && e.type === 'Soldier' && !e.dead && e.state === 'IDLE').length;
                    return soldiers >= 3;
                },
                action: () => {
                    const soldiers = state.entities.filter(e => e.owner === 'enemy' && e.type === 'Soldier' && !e.dead && e.state === 'IDLE');
                    const players = state.entities.filter(e => e.owner === 'player' && !e.dead);
                    
                    if (soldiers.length > 0 && players.length > 0) {
                        const target = players.sort((a,b) => a.position.distanceTo(soldiers[0].position) - b.position.distanceTo(soldiers[0].position))[0];
                        soldiers.forEach(s => {
                            s.state = 'ATTACK';
                            s.targetEntity = target;
                        });
                    }
                }
            }
        ];

        function aiTick() {
            if (!state.isPlaying) return;
            const now = Date.now();
            if (now - state.aiMemory.lastActionTime < CONFIG.AI_APM_LIMIT) return;

            for (let rule of AI_RULES) {
                if (rule.condition()) {
                    console.log("Triggered rule: " + rule.name);
                    rule.action();
                    state.aiMemory.lastActionTime = now;
                    break;
                }
            }
        }

        function getEnemyTownCenter() {
            return state.entities.find(e => e.owner === 'enemy' && e.type === 'TownCenter' && !e.dead);
        }
        function getEnemyVillager(idleOnly = false) {
            return state.entities.find(e => 
                e.owner === 'enemy' && 
                e.type === 'Villager' && 
                !e.dead && 
                (!idleOnly || e.state === 'IDLE')
            );
        }

        // --- INPUT & INTERACTION ---

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let dragStart = new THREE.Vector2();
        const selectionBoxDiv = document.getElementById('selection-box');
        const canvas = renderer.domElement;

        // Camera Panning (Arrow Keys)
        window.addEventListener('keydown', (e) => {
            state.keysPressed[e.key] = true;
            // Hotkeys for game logic
            if (!state.isPlaying) return;
            const k = e.key.toLowerCase();
            if (k === '.') selectAllIdleVillagers(); //add back idle selection
            if (k === 'escape') {
                if (state.buildingMode) cancelBuildingMode();
                else clearSelection();
            }
            const first = state.selection[0];
            if (first instanceof Unit && first.type === 'Villager') {
                if (k === 'h') startBuildingMode('House', CONFIG.COSTS.HOUSE);
                if (k === 'b') startBuildingMode('Barracks', CONFIG.COSTS.BARRACKS);
            }
            if (first instanceof Building) {
                if (first.type === 'TownCenter' && k === 'v') trainUnit(first, 'Villager', CONFIG.COSTS.VILLAGER, 'player');
                if (first.type === 'Barracks' && k === 's') trainUnit(first, 'Soldier', CONFIG.COSTS.SOLDIER, 'player');
            }
        });
        window.addEventListener('keyup', (e) => state.keysPressed[e.key] = false);

        canvas.addEventListener('mousedown', (e) => {
            if (e.target.closest('#ui-layer')) return;
            if (e.button !== 0) return;
            if (state.buildingMode) {
                confirmBuildPlacement();
                return;
            }

            isDragging = true;
            const rect = canvas.getBoundingClientRect();
            dragStart.set(e.clientX - rect.left, e.clientY - rect.top);
            selectionBoxDiv.style.left = dragStart.x + 'px';
            selectionBoxDiv.style.top = dragStart.y + 'px';
            selectionBoxDiv.style.width = '0px';
            selectionBoxDiv.style.height = '0px';
            selectionBoxDiv.style.display = 'block';

            if (!e.shiftKey) clearSelection();
        });

        window.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            if (state.buildingMode) {
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(ground);
                if (intersects.length > 0) state.ghostMesh.position.copy(intersects[0].point);
                return;
            }

            if (isDragging) {
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                const w = Math.abs(currentX - dragStart.x);
                const h = Math.abs(currentY - dragStart.y);
                const l = Math.min(currentX, dragStart.x);
                const t = Math.min(currentY, dragStart.y);
                selectionBoxDiv.style.width = w + 'px';
                selectionBoxDiv.style.height = h + 'px';
                selectionBoxDiv.style.left = l + 'px';
                selectionBoxDiv.style.top = t + 'px';
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (e.button !== 0) return;
            if (state.buildingMode) return;
            
            isDragging = false;
            selectionBoxDiv.style.display = 'none';

            const rect = canvas.getBoundingClientRect();
            const dragEnd = new THREE.Vector2(e.clientX - rect.left, e.clientY - rect.top);
            const dist = dragStart.distanceTo(dragEnd);

            if (dist < 5) {
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children, true);
                let clickedEntity = null;
                for (let hit of intersects) {
                    if (hit.object.userData.entity) {
                        clickedEntity = hit.object.userData.entity;
                        //console.log(clickedEntity);
                        break;
                    }
                    if (hit.object.parent.userData.entity) {
                        clickedEntity = hit.object.parent.userData.entity;
                        //console.log(clickedEntity);
                        break;
                    }
                }
                selectEntity(clickedEntity, e.shiftKey);
            } else {
                boxSelection(dragStart, dragEnd);
            }
        });

        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (state.buildingMode) { cancelBuildingMode(); return; }
            if (state.selection.length === 0) return;

            const rect = canvas.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            let targetEntity = null;
            let groundPoint = null;
            for (let hit of intersects) {
                if (hit.object.userData.entity) { targetEntity = hit.object.userData.entity; break; }
                else if (hit.object.parent.userData.entity) { targetEntity = hit.object.parent.userData.entity; break; }
                else if (hit.object.name === "Ground") { groundPoint = hit.point; }
            }

            state.selection.forEach(unit => {
                if (unit instanceof Unit) {
                    if (targetEntity) {
                        if (targetEntity.owner === 'enemy') {
                            unit.state = 'ATTACK'; unit.targetEntity = targetEntity;
                        } else if (targetEntity instanceof Resource) {
                            unit.state = 'GATHER'; unit.targetEntity = targetEntity; unit.gatherType = targetEntity.meshType;
                        } else {
                            unit.state = 'MOVE'; unit.targetPos = targetEntity.position;
                        }
                    } else if (groundPoint) {
                        unit.state = 'MOVE'; unit.targetPos = groundPoint;
                        createClickMarker(groundPoint);
                    }
                }
                if (unit instanceof Building) {
                    if (targetEntity) {
                        console.log("Not impl yet");
                    } else if (groundPoint) {
                        unit.gatherPointPos = groundPoint;
                        createClickMarker(groundPoint);
                    }
                }
            });
        });

        function selectAllIdleVillagers() {
            clearSelection();
            state.entities.forEach(e => {
                if (e instanceof Unit && e.owner === 'player' && e.type === 'Villager' && e.state === 'IDLE') {
                    state.selection.push(e);
                    e.setSelected(true);
                }
            });
            updateUISelection();
            if (state.selection.length > 0) { notify(`Selected ${state.selection.length} idle villagers`); }
            else { notify(`No idle villagers`); }
        }

        // --- SELECTION & UI ---

        function selectEntity(entity, additive) {
            if (!additive) clearSelection();
            if (entity && entity.owner === 'player') {
                if (entity instanceof Unit) {
                    if (!state.selection.includes(entity)) {
                        state.selection.push(entity);
                        entity.setSelected(true);
                    }
                } else if (entity instanceof Building) {
                    clearSelection();
                    state.selection.push(entity);
                    entity.setSelected(true);
                }
            }
            updateUISelection();
        }

        function boxSelection(start, end) {
            clearSelection();
            const left = Math.min(start.x, end.x);
            const right = Math.max(start.x, end.x);
            const top = Math.min(start.y, end.y);
            const bottom = Math.max(start.y, end.y);

            state.entities.forEach(entity => {
                if (entity instanceof Unit && entity.owner === 'player') {
                    const screenPos = entity.position.clone().project(camera);
                    const x = (screenPos.x + 1) / 2 * window.innerWidth;
                    const y = -(screenPos.y - 1) / 2 * window.innerHeight;
                    if (x >= left && x <= right && y >= top && y <= bottom) {
                        state.selection.push(entity);
                        entity.setSelected(true);
                    }
                }
            });
            updateUISelection();
        }

        function clearSelection() {
            state.selection.forEach(e => e.setSelected(false));
            state.selection = [];
            updateUISelection();
        }

        function updateUI() {
            document.getElementById('res-wood').innerText = Math.floor(state.playerResources.wood);
            document.getElementById('res-food').innerText = Math.floor(state.playerResources.food);
            document.getElementById('res-gold').innerText = Math.floor(state.playerResources.gold);
            document.getElementById('res-oil').innerText = Math.floor(state.playerResources.oil);
            document.getElementById('res-pop').innerText = state.playerPop;
            document.getElementById('res-max-pop').innerText = state.playerMaxPop;
        }

        function updateUISelection() {
            const nameEl = document.getElementById('selection-name');
            const statsEl = document.getElementById('selection-stats');
            const queueEl = document.getElementById('queue-info');
            const grid = document.getElementById('actions-grid');
            grid.innerHTML = '';

            if (state.selection.length === 0) {
                nameEl.innerText = "Nothing Selected";
                statsEl.innerText = "";
                queueEl.innerText = "";
                return;
            }

            const first = state.selection[0];
            if (state.selection.length > 1) {
                nameEl.innerText = `${state.selection.length} Units`;
                statsEl.innerText = "Ready";
                queueEl.innerText = "";
            } else {
                nameEl.innerText = first.type;
                statsEl.innerText = `HP: ${Math.floor(first.hp)}/${first.maxHp}`;
                queueEl.innerText = ""; // Reset

                if (first instanceof Building) {
                    // Display Queue Info
                    if (first.productionQueue.length > 0) {
                        const current = first.productionQueue[0];
                        const pct = Math.min(100, (first.productionTimer / (CONFIG.BUILD_TIMES[current.type]||3)) * 100);
                        queueEl.innerText = `Producing: ${current.type} (${first.productionQueue.length} in queue) [${Math.floor(pct)}%]`;
                    } else {
                        queueEl.innerText = "Idle";
                    }

                    if (first.type === 'TownCenter') createActionButton('Train Villager', '50 Food', 'V');
                    if (first.type === 'Barracks') createActionButton('Train Soldier', '60F / 20G', 'S');
                }
                
                if (first instanceof Unit && first.type === 'Villager') {
                    createActionButton('Build House', '30 Wood', 'H');
                    createActionButton('Build Barracks', '150 Wood', 'B');
                }
            }
        }

        function createActionButton(label, cost, key) {
            const btn = document.createElement('button');
            btn.className = 'action-btn';
            btn.innerHTML = `<span>${label}</span><span class="cost-tooltip">${cost}</span><span class="hotkey">${key}</span>`;
            
            // Robust click handler
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();

                // Re-verify selection exists
                if (state.selection.length === 0) return;
                const first = state.selection[0];
                
                const k = key.toLowerCase();
                if (first instanceof Building) {
                    if (first.type === 'TownCenter' && k === 'v') trainUnit(first, 'Villager', CONFIG.COSTS.VILLAGER, 'player');
                    if (first.type === 'Barracks' && k === 's') trainUnit(first, 'Soldier', CONFIG.COSTS.SOLDIER, 'player');
                }
                else if (first instanceof Unit) {
                    if (first.type === 'Villager' && k === 'h') startBuildingMode('House', CONFIG.COSTS.HOUSE);
                    if (first.type === 'Villager' && k === 'b') startBuildingMode('Barracks', CONFIG.COSTS.BARRACKS);
                }
            });
            
            document.getElementById('actions-grid').appendChild(btn);
        }

        // --- CONSTRUCTION SYSTEM ---

        function startBuildingMode(type, cost) {
            if (state.playerResources.wood < (cost.wood||0)) { notify("Not enough Wood!"); return; }
            // Deduct cost immediately
            state.playerResources.wood -= (cost.wood||0);
            updateUI();

            state.buildingMode = { type, cost };
            
            //let geo;
            //if (type === 'House') geo = new THREE.BoxGeometry(5, 5, 4);
            //else if (type === 'Barracks') geo = new THREE.BoxGeometry(8, 5, 6);
            
            const mat = new THREE.MeshBasicMaterial({ color: CONFIG.COLORS.GHOST, transparent: true, opacity: 0.5, wireframe: true });
            //state.ghostMesh = new THREE.Mesh(geo, mat);
            //state.ghostMesh.position.y = 2.5;
            state.ghostMesh = AssetFactory.create(type, "kingdom", CONFIG.COLORS.GHOST, mat);
            scene.add(state.ghostMesh);
        }

        function confirmBuildPlacement() {
            if (!state.buildingMode) return;
            const pos = state.ghostMesh.position.clone();
            pos.y = 0;
            
            // Find a Villager to construct
            let builder = null;
            
            // 1. Check if selected unit is a villager
            if (state.selection.length > 0 && state.selection[0] instanceof Unit && state.selection[0].type === 'Villager') {
                builder = state.selection[0];
            }
            
            // 2. If not, find nearest idle villager
            if (!builder) {
                let minDist = Infinity;
                state.entities.forEach(e => {
                    if (e instanceof Unit && e.owner === 'player' && e.type === 'Villager' && e.state === 'IDLE') {
                        const d = e.position.distanceTo(pos);
                        if (d < minDist) { minDist = d; builder = e; }
                    }
                });
            }

            if (builder) {
                // Success: Assign construction task
                builder.state = 'CONSTRUCT';
                builder.targetPos = pos;
                builder.constructType = state.buildingMode.type;
                builder.constructTimer = 0;

                //TODO: show visual of foundation
                let w = 8, h = 0.4, d = 8;
                const geometry = new THREE.BoxGeometry(w, h, d);
                const material = new THREE.MeshStandardMaterial({ color: CONFIG.COLORS.FOUNDATION });
                const foundationMesh = new THREE.Mesh(geometry, material);
                foundationMesh.position.copy(pos);
                foundationMesh.position.y = h/2;
                scene.add(foundationMesh);
                builder.temporaryFoundationMesh = foundationMesh;
                
                cancelBuildingModeUI(); // Just removes ghost, cost already paid
            } else {
                // Failure: Refund and warn
                notify("Need an Idle Villager to build!");
                state.playerResources.wood += state.buildingMode.cost.wood || 0;
                updateUI();
                cancelBuildingMode();
            }
        }

        function cancelBuildingModeUI() {
            if (state.ghostMesh) scene.remove(state.ghostMesh);
            state.ghostMesh = null;
            state.buildingMode = null;
        }

        function cancelBuildingMode() {
            // If cancelling before placement, we might have already deducted in startBuildingMode
            // But currently we deduct in startBuildingMode.
            // If user cancels (e.g. right click), we should refund.
            if (state.buildingMode) {
                state.playerResources.wood += state.buildingMode.cost.wood || 0;
                updateUI();
                notify("Build Cancelled");
            }
            cancelBuildingModeUI();
        }

        // --- FX ---
        function createClickMarker(pos) {
            const geo = new THREE.RingGeometry(0.5, 1, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.position.y += 0.2;
            mesh.rotation.x = -Math.PI / 2;
            scene.add(mesh);
            
            let scale = 1;
            function anim() {
                scale -= 0.05;
                mesh.scale.setScalar(scale);
                mat.opacity = scale;
                if (scale > 0) requestAnimationFrame(anim);
                else scene.remove(mesh);
            }
            anim();
        }

        function showFloatText(text, pos) {
            const div = document.createElement('div');
            div.innerText = text;
            div.style.position = 'absolute';
            div.style.color = '#fff';
            div.style.fontWeight = 'bold';
            div.style.fontSize = '16px';
            div.style.textShadow = '1px 1px 0 #000';
            div.style.pointerEvents = 'none';
            div.style.transition = 'top 1s, opacity 1s';
            document.body.appendChild(div);

            const screenPos = pos.clone().project(camera);
            const x = (screenPos.x + 1) / 2 * window.innerWidth;
            const y = -(screenPos.y - 1) / 2 * window.innerHeight;

            div.style.left = x + 'px';
            div.style.top = y + 'px';

            requestAnimationFrame(() => {
                div.style.top = (y - 50) + 'px';
                div.style.opacity = 0;
            });
            setTimeout(() => div.remove(), 1000);
        }

        function notify(msg) {
            const area = document.getElementById('notification-area');
            const t = document.createElement('div');
            t.className = 'toast';
            t.innerText = msg;
            area.appendChild(t);
            setTimeout(() => t.remove(), 3000);
        }

        // --- LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            
            // Arrow Key Panning Logic
            const panSpeed = 50 * dt;
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();

            if (state.keysPressed['ArrowUp']) {
                camera.position.add(forward.multiplyScalar(panSpeed));
                controls.target.add(forward);
            }
            if (state.keysPressed['ArrowDown']) {
                camera.position.add(forward.multiplyScalar(-panSpeed));
                controls.target.add(forward);
            }
            if (state.keysPressed['ArrowLeft']) {
                camera.position.add(right.multiplyScalar(-panSpeed));
                controls.target.add(right);
            }
            if (state.keysPressed['ArrowRight']) {
                camera.position.add(right.multiplyScalar(panSpeed));
                controls.target.add(right);
            }

            state.entities = state.entities.filter(e => !e.dead);
            state.entities.forEach(e => e.update(dt));
            
            controls.update();
            renderer.render(scene, camera);
        }

        window.startGame = function() {
            document.getElementById('start-screen').style.display = 'none';
            initGame();
        };

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect; camera.right = d * aspect;
            camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
